<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>The Collegiate EMS Mapping Project</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

    <style>
      :root {
        --sidebar-w: 360px;
        --muted: #666;
        --accent: #0b66ff;
      }

      html, body {
        height: 100%;
        margin: 0;
        font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
        font-size: 13px;
      }

      #sidebar {
        position: absolute;
        top: 0;
        left: 0;
        width: var(--sidebar-w);
        height: 100vh;
        background: #fff;
        border-right: 1px solid #e6e9ee;
        padding: 12px;
        box-sizing: border-box;
        overflow-y: auto;
        z-index: 999;
      }

      #map {
        position: absolute;
        left: var(--sidebar-w);
        top: 0;
        width: calc(100vw - var(--sidebar-w));
        height: 100vh;
      }

      .controls-row { display:flex; gap:8px; }
      button, input[type="file"] {
        display: block;
        width: 100%;
        padding: 8px 10px;
        margin-top: 8px;
        box-sizing: border-box;
        border-radius: 6px;
        border: 1px solid #cfd6df;
        background: #f7f9fb;
        cursor: pointer;
      }
      button:disabled { opacity: 0.6; cursor: not-allowed; }

      .section-title {
        margin-top: 14px;
        font-weight: 600;
        font-size: 14px;
      }

      .small-note { color: var(--muted); font-size: 12px; }

      .filters { display:grid; grid-template-columns:repeat(3,1fr); gap:6px; margin-top:8px; }

      label.filter-item { display:inline-flex; align-items:center; gap:6px; cursor:pointer; user-select:none; font-size:13px; }

      .legend { margin-top:12px; }
      .legend-bar { height: 14px; border-radius:4px; margin-top:6px; }

      .counts { margin-top:8px; font-size:13px; color:#111827; white-space:pre-wrap; }

      .polygon-details { margin-top:12px; border-top:1px dashed #e6e9ee; padding-top:10px; }

      .details-title { display:flex; justify-content:space-between; align-items:center; gap:10px; }

      .details-scroll { max-height: 220px; overflow:auto; margin-top:8px; border:1px solid #f1f3f5; border-radius:6px; }

      .details-table { width:100%; border-collapse:collapse; margin-top:8px; }
      .details-table th, .details-table td { border:1px solid #e6e9ee; padding:6px 8px; font-size:13px; text-align:left; }

      .summary-block { margin-top:10px; font-size:13px; }
      .day-section { border:1px solid #eef2f6; border-radius:6px; margin-top:8px; overflow:hidden; }
      .day-header { display:flex; justify-content:space-between; align-items:center; padding:8px 10px; cursor:pointer; background:#fafbfc; }
      .day-title { font-weight:600; }
      .day-body { padding:8px 12px; display:none; background:#fff; }
      .shift-line { margin-left:8px; font-size:13px; color:#111827; }
      .muted { color:var(--muted); }

      .poly-label { background: rgba(255,255,255,0.95); padding:4px 8px; border-radius:6px; border:1px solid #cbd5e1; font-size:13px; color:#0f172a; box-shadow: 0 1px 2px rgba(0,0,0,0.06); }

      .top-controls { display:flex; gap:8px; margin-bottom:6px; }
      
      .poly-popup {
        min-width: 300px;
        max-width: 300px;
        max-height: 300px;
        overflow-y: auto;
        font-family: inherit;
      }
      
      .popup-table-wrapper {
        overflow-x: auto;
        max-width: 100%;
      }
      
      .popup-title {
        font-weight: 600;
        font-size: 14px;
        margin-bottom: 8px;
        padding-bottom: 6px;
        border-bottom: 2px solid #e5e7eb;
      }
      
      .popup-section {
        margin-top: 10px;
        border: 1px solid #e5e7eb;
        border-radius: 6px;
        overflow: hidden;
      }
      
      .popup-section-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 10px;
        background: #f9fafb;
        cursor: pointer;
        font-size: 13px;
        font-weight: 600;
      }
      
      .popup-section-header:hover {
        background: #f3f4f6;
      }
      
      .popup-section-body {
        padding: 8px 10px;
        font-size: 12px;
        background: #fff;
      }
      
      .filter-section {
        margin-top: 12px;
        padding: 10px;
        background: #f9fafb;
        border-radius: 6px;
        border: 1px solid #e5e7eb;
      }
      
      .filter-section-title {
        font-weight: 600;
        margin-bottom: 6px;
        font-size: 13px;
      }

      .loading-indicator {
        color: #0b66ff;
        font-size: 12px;
        font-style: italic;
        margin-top: 8px;
      }

      /* Collapsible box styles */
      .collapsible-box {
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        margin-bottom: 12px;
        background: #fff;
        overflow: hidden;
      }

      .collapsible-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 12px;
        background: #f9fafb;
        cursor: pointer;
        font-weight: 600;
        font-size: 14px;
        user-select: none;
      }

      .collapsible-header:hover {
        background: #f3f4f6;
      }

      .collapsible-content {
        padding: 12px;
        background: #fff;
      }

      .collapsible-content.collapsed {
        display: none;
      }

      .collapse-icon {
        color: #6b7280;
        font-size: 12px;
        transition: transform 0.2s;
      }

      .collapse-icon.collapsed {
        transform: rotate(-90deg);
      }

      .subsection-title {
        font-weight: 600;
        font-size: 13px;
        margin-top: 12px;
        margin-bottom: 6px;
        color: #374151;
      }

      .subsection-title:first-child {
        margin-top: 0;
      }
    </style>
  </head>

  <body>
    <div id="sidebar" style="font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">
      <!-- Collapsible Map Settings Box -->
      <div class="collapsible-box">
        <div class="collapsible-header" onclick="toggleCollapsible('mapSettings')" style="background:#83be5c">
          <span style="color:#1b3907;">Map Settings and File Uploads</span>
          <span class="collapse-icon collapsed" id="mapSettings-icon">▼</span>
        </div>
        <div class="collapsible-content collapsed" id="mapSettings-content" style="background:#83be5c22">
          
          <!-- Map Center -->
          <div class="subsection-title" style="margin-bottom:0px">Map Center Coordinates</div>
          <div class="controls-row">
            <button id="setMapCenterBtn" style="background:#83be5cb1;color:#1b3907">Set Map Center</button>
            <button id="resetMapCenterBtn" style="background:#83be5cb1;color:#1b3907">Reset to Default</button>
          </div>
          <div id="mapCenterCoords" class="small-note" style="margin-top:6px; margin-bottom:10px">Default: Lat 32.985, Lng -96.75, Zoom 16</div>
          <hr style="border: none; border-top: 2px solid #1b3907; margin: 12px 0;" />
          <!-- Station Location -->
          <div class="subsection-title">Station Location</div>
          <button id="setStationBtn" style="background:#83be5cb1;color:#1b3907">Set Station</button>
          <div id="stationCoords" class="small-note" style="margin-top:6px;">Station not set (required for Distance/Time Map)</div>
          <hr style="border: none; border-top: 2px solid #1b3907; margin: 12px 0;" />
          <!-- Area Selection Tool -->
          <div class="subsection-title" style="margin-bottom: 0px;">Area Selection Tool</div>
          <div class="controls-row">
            <button id="startBtn" style="background:#83be5cb1;color:#1b3907">Start New Area</button>
            <button id="finishBtn" disabled style="background:#83be5cb1;color:#1b3907">Finish</button>
            <button id="exportPolygonsBtn" style="background:#83be5cb1;color:#1b3907">Export Current Areas</button>
          </div>
          <div class="subsection-title" style="text-indent: 10px;">Or Upload Areas</div>
          <input id="importPolygonsFile" name="importSelectionsFile" type="file" accept=".json" style="margin-top:8px; margin-left:10px; width: calc(100% - 10px); background:#83be5c58;color:#1b3907" />
          <div class="small-note" id="csvRequirements" style="margin-top:6px; margin-left:10px; font-style: italic; color:#635886b1">Upload a .JSON file here.</div>
          <hr style="border: none; border-top: 2px solid #1b3907; margin: 12px 0;" />
          <!-- Incident Data -->
          <div class="subsection-title">Upload Incident Data</div>
          <input id="csvFile" type="file" accept=".csv,text/csv" style="margin-top:0; background:#83be5c58;color:#1b3907" />
          <div class="small-note" id="csvRequirements" style="margin-top:6px; font-style: italic; color:#635886b1">Upload a .CSV file here. The first column should contain location IDs that match those of your area selections. Include a "timeElapsed" column for a Distance/Time analysis.</div>
          <hr style="border: none; border-top: 2px solid #1b3907; margin: 12px 0;" />
          <button id="resetDataBtn" title="Remove uploaded CSV rows but keep polygons" style="margin-top:8px;background:#83be5cb1;color:#1b3907">Clear Incident Data Only</button>
          <button id="resetBtn" style="background:#83be5cb1;color:#1b3907">Reset All Incidents and Areas</button>
          <div id="polygonList" class="counts muted" style="margin-top:6px; text-align:center; font-weight:500; color:#1b390798">0 Saved Area(s)</div>
        </div>
      </div>

      <!-- Toggle Labels (outside collapsible) -->
      <label class="filter-item" style="margin-bottom:12px; font-weight: 600;">
        <input type="checkbox" id="toggleLabels" checked /> Toggle Area Labels
      </label>

      <!-- Heatmap Mode -->
      <div class="section-title">Heatmap Mode</div>
      <label class="filter-item">
        <input type="radio" name="heatmapMode" value="incidents" checked /> Incident Count
      </label>
      <label class="filter-item">
        <input type="radio" name="heatmapMode" value="distance" /> Distance/Time Map
      </label>
      <div id="distanceLoadingIndicator" class="loading-indicator" style="display:none;">Calculating distances...</div>

      <!-- Filter Selections -->
      <div class="section-title" style="margin-bottom: 15px;">Filter Selections</div>
      <div id="dynamicFiltersContainer">
        <div class="small-note">Upload a CSV to see available filters</div>
      </div>
      <div style="margin-top:12px; display:flex; gap:8px;">
        <button id="clearFiltersBtn">Clear Filters</button>
      </div>

      <!-- Legend -->
      <div class="legend">
        <div style="font-weight:600">Legend</div>
        <div class="legend-bar" id="legendBar" style="background: linear-gradient(90deg, rgba(91, 91, 91, 0.15), rgba(0,0,255,0.9));"></div>
        <div class="small-note" id="legendText">Gray = fewer incidents; Blue = greater incidents</div>
      </div>

      <!-- Broad Summary -->
      <div class="section-title">Broad Summary</div>
      <div id="csvSummary" class="counts muted">No CSV loaded</div>

      <div id="summaryContainer" class="summary-block" style="display:none;"></div>

      <div class="details-scroll" id="detailsScroll" style="display:none;">
        <table class="details-table" id="detailsTable">
          <thead id="detailsTableHead">
            <tr></tr>
          </thead>
          <tbody id="detailsTbody"></tbody>
        </table>
      </div>
    </div>

    <div id="map"></div>

    <script>
      // Collapsible box toggle function
      function toggleCollapsible(sectionId) {
        const content = document.getElementById(sectionId + '-content');
        const icon = document.getElementById(sectionId + '-icon');
        
        if (content.classList.contains('collapsed')) {
          content.classList.remove('collapsed');
          icon.classList.remove('collapsed');
        } else {
          content.classList.add('collapsed');
          icon.classList.add('collapsed');
        }
      }

      // Default map center 32.985962, -96.750402, 16
      const DEFAULT_MAP_CENTER = { lat: 32.985962, lng: -96.750402, zoom: 16 };
      const LS_MAP_CENTER = 'map_center_v1';
      
      // Load saved map center or use default
      let mapCenter = DEFAULT_MAP_CENTER;
      try {
        const saved = localStorage.getItem(LS_MAP_CENTER);
        if (saved) {
          mapCenter = JSON.parse(saved);
        }
      } catch (e) {}
      
      const map = L.map('map').setView([mapCenter.lat, mapCenter.lng], mapCenter.zoom);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

      let drawing = false;
      let polygonPoints = [];
      let tempPolygon = null;
      let polygons = [];
      let csvRows = [];
      let _station = null;
      let activeRouteLine = null;

      // Dynamic filter tracking
      let csvColumns = [];
      let locationColumnName = '';
      let filterableColumns = [];
      let activeFilters = {};

      // Distance/time caching
      let distanceDataCalculated = false;
      let distanceCache = {}; // Map of polygon name -> { distance: meters, avgTime: seconds, ratio: number }

      const LS_POLYGONS = 'polygons_v3';
      const LS_CSV = 'polygons_csv_rows_v3';
      const LS_STATION = 'station_location_v1';
      const LS_DISTANCE_CACHE = 'distance_cache_v1';

      // Save station to localStorage
      function saveStationToLocalStorage() {
        try {
          if (_station && _station.latlng) {
            localStorage.setItem(LS_STATION, JSON.stringify({
              lat: _station.latlng.lat,
              lng: _station.latlng.lng
            }));
          } else {
            localStorage.removeItem(LS_STATION);
          }
        } catch (e) {
          console.error('Failed to save station:', e);
        }
      }

      // Save distance cache to localStorage
      function saveDistanceCacheToLocalStorage() {
        try {
          if (Object.keys(distanceCache).length > 0) {
            localStorage.setItem(LS_DISTANCE_CACHE, JSON.stringify({
              cache: distanceCache,
              calculated: distanceDataCalculated
            }));
          } else {
            localStorage.removeItem(LS_DISTANCE_CACHE);
          }
        } catch (e) {
          console.error('Failed to save distance cache:', e);
        }
      }

      // Load distance cache from localStorage
      function loadDistanceCacheFromLocalStorage() {
        try {
          const raw = localStorage.getItem(LS_DISTANCE_CACHE);
          if (!raw) return;
          
          const data = JSON.parse(raw);
          if (data.cache && typeof data.cache === 'object') {
            distanceCache = data.cache;
            distanceDataCalculated = data.calculated || false;
          }
        } catch (e) {
          console.error('Failed to load distance cache:', e);
        }
      }

      // Load station from localStorage
      function loadStationFromLocalStorage() {
        try {
          const raw = localStorage.getItem(LS_STATION);
          if (!raw) return;
          
          const data = JSON.parse(raw);
          if (!data.lat || !data.lng) return;
          
          const latlng = L.latLng(data.lat, data.lng);
          const marker = L.marker(latlng, { draggable: true }).addTo(map);
          marker.bindPopup('Station');
          
          marker.on('dragend', () => {
            _station.latlng = marker.getLatLng();
            updateStationDisplay();
            saveStationToLocalStorage();
            
            // Invalidate distance calculations when station moved
            distanceDataCalculated = false;
            distanceCache = {};
            saveDistanceCacheToLocalStorage();
          });

          marker.on('contextmenu', () => {
            map.removeLayer(marker);
            _station = null;
            updateStationDisplay();
            saveStationToLocalStorage();
            
            // Invalidate distance calculations when station removed
            distanceDataCalculated = false;
            distanceCache = {};
            saveDistanceCacheToLocalStorage();
            updateShading();
          });

          _station = { marker, latlng };
          updateStationDisplay();
        } catch (e) {
          console.error('Failed to load station:', e);
        }
      }

      // Update station coordinates display
      function updateStationDisplay() {
        const display = document.getElementById('stationCoords');
        if (_station && _station.latlng) {
          display.innerText = `Lat: ${_station.latlng.lat.toFixed(6)}, Lng: ${_station.latlng.lng.toFixed(6)}`;
        } else {
          display.innerText = 'Station not set (required for Distance/Time Map)';
        }
      }

      // Update map center display
      function updateMapCenterDisplay() {
        const display = document.getElementById('mapCenterCoords');
        if (mapCenter.lat === DEFAULT_MAP_CENTER.lat && 
            mapCenter.lng === DEFAULT_MAP_CENTER.lng && 
            mapCenter.zoom === DEFAULT_MAP_CENTER.zoom) {
          display.textContent = `Default: Lat ${mapCenter.lat}, Lng ${mapCenter.lng}, Zoom ${mapCenter.zoom}`;
        } else {
          display.textContent = `Custom: Lat ${mapCenter.lat.toFixed(6)}, Lng ${mapCenter.lng.toFixed(6)}, Zoom ${mapCenter.zoom}`;
        }
      }

      // Set map center button
      document.getElementById('setMapCenterBtn').addEventListener('click', () => {
        const currentCenter = map.getCenter();
        const currentZoom = map.getZoom();
        
        const input = prompt(
          `Enter coordinates and zoom level:\n\n` +
          `Format: latitude, longitude, zoom\n` +
          `Example: 32.985, -96.75, 16\n\n` +
          `Current: ${currentCenter.lat.toFixed(6)}, ${currentCenter.lng.toFixed(6)}, ${currentZoom}`,
          `${currentCenter.lat.toFixed(6)}, ${currentCenter.lng.toFixed(6)}, ${currentZoom}`
        );
        
        if (input === null) return; // User cancelled
        
        const parts = input.split(',').map(p => p.trim());
        
        if (parts.length !== 3) {
          alert('Invalid format. Please enter: latitude, longitude, zoom');
          return;
        }
        
        const lat = parseFloat(parts[0]);
        const lng = parseFloat(parts[1]);
        const zoom = parseInt(parts[2]);
        
        if (isNaN(lat) || isNaN(lng) || isNaN(zoom)) {
          alert('Invalid coordinates or zoom level. Please enter valid numbers.');
          return;
        }
        
        if (lat < -90 || lat > 90) {
          alert('Latitude must be between -90 and 90.');
          return;
        }
        
        if (lng < -180 || lng > 180) {
          alert('Longitude must be between -180 and 180.');
          return;
        }
        
        if (zoom < 1 || zoom > 18) {
          alert('Zoom level must be between 1 and 18.');
          return;
        }
        
        // Save to localStorage
        mapCenter = { lat, lng, zoom };
        try {
          localStorage.setItem(LS_MAP_CENTER, JSON.stringify(mapCenter));
        } catch (e) {}
        
        // Update map view
        map.setView([lat, lng], zoom);
        
        // Update display
        updateMapCenterDisplay();
        
        alert('Map center saved successfully!');
      });

      // Reset map center button
      document.getElementById('resetMapCenterBtn').addEventListener('click', () => {
        // Reset to default
        mapCenter = { ...DEFAULT_MAP_CENTER };
        
        try {
          localStorage.removeItem(LS_MAP_CENTER);
        } catch (e) {}
        
        // Update map view
        map.setView([mapCenter.lat, mapCenter.lng], mapCenter.zoom);
        
        // Update display
        updateMapCenterDisplay();
        
        alert('Map center reset to default!');
      });

      function savePolygonsToLocalStorage() {
        try {
          const simple = polygons.map(p => ({ name: p.name, coords: p.coords }));
          localStorage.setItem(LS_POLYGONS, JSON.stringify(simple));
        } catch (e) {}
      }
      
      function loadPolygonsFromLocalStorage() {
        try {
          const raw = localStorage.getItem(LS_POLYGONS);
          if (!raw) return;
          const items = JSON.parse(raw);
          if (!Array.isArray(items)) return;
          items.forEach(p => {
            const layer = L.polygon(p.coords, { color:'blue', fillColor:'rgba(0,0,255,0.4)', weight:2 }).addTo(map);
            const polyObj = { name: p.name, coords: p.coords, layer };
            polygons.push(polyObj);
            createLabelForPolygon(polyObj);
          });
          updatePolygonList();
        } catch (e) {}
      }

      function saveCsvToLocalStorage() {
        try { 
          localStorage.setItem(LS_CSV, JSON.stringify({
            rows: csvRows,
            columns: csvColumns,
            locationColumn: locationColumnName,
            filterableColumns: filterableColumns
          })); 
        } catch (e) {}
      }
      
      function loadCsvFromLocalStorage() {
        try {
          const raw = localStorage.getItem(LS_CSV);
          if (!raw) return;
          const data = JSON.parse(raw);
          csvRows = data.rows || [];
          csvColumns = data.columns || [];
          locationColumnName = data.locationColumn || '';
          filterableColumns = data.filterableColumns || [];
          
          if (csvRows.length > 0) {
            // Initialize active filters
            activeFilters = {};
            filterableColumns.forEach(col => {
              activeFilters[col] = new Set();
            });
            
            buildDynamicFilters();
            updateCsvSummary();
          }
        } catch (e) {}
      }

      function createLabelForPolygon(poly) {
        let latSum = 0, lngSum = 0;
        poly.coords.forEach(c => { latSum += c[0]; lngSum += c[1]; });
        const centroid = [latSum / poly.coords.length, lngSum / poly.coords.length];
        poly.centroid = centroid; // Store centroid for routing
        
        const icon = L.divIcon({ className: 'poly-label', html: `${poly.name}`, iconSize: null });
        const marker = L.marker(centroid, { icon }).addTo(map);
        poly.label = marker;

        // Click on label or polygon shows popup
        marker.on('click', () => {
          showPolygonPopup(poly);
        });
        poly.layer.on('click', () => {
          showPolygonPopup(poly);
        });
        
        // Right-click to delete
        poly.layer.on('contextmenu', function (e) {
          try { e.originalEvent.preventDefault(); } catch (_) {}
          if (!confirm(`Delete polygon "${poly.name}"?`)) return;
          const idx = polygons.findIndex(p => p.layer === poly.layer);
          if (idx >= 0) deletePolygon(idx);
        });
      }

      document.getElementById('toggleLabels').addEventListener('change', e => {
        const show = e.target.checked;
        polygons.forEach(p => {
          if (!p.label) return;
          if (show) {
            if (!map.hasLayer(p.label)) p.label.addTo(map);
          } else {
            if (map.hasLayer(p.label)) map.removeLayer(p.label);
          }
        });
      });

      document.querySelectorAll('input[name="heatmapMode"]').forEach(radio => {
        radio.addEventListener('change', async () => {
          const mode = radio.value;
          
          if (mode === 'distance') {
            // Update legend
            document.getElementById('legendBar').style.background = 'linear-gradient(90deg, rgba(255,0,0,0.9), rgba(0,255,0,0.3))';
            document.getElementById('legendText').textContent = 'Red = Slower/Green = Faster Estimated Avg. Velocity';
            
            if (!_station) {
              alert('Please set a station location first for Distance/Time Map');
              document.querySelector('input[name="heatmapMode"][value="incidents"]').checked = true;
              // Reset legend back
              document.getElementById('legendBar').style.background = 'linear-gradient(90deg, rgba(170,170,170,0.15), rgba(255,0,0,0.9))';
              document.getElementById('legendText').textContent = 'Gray = fewer incidents; Blue = greater incidents';
              return;
            }
            
            if (!csvColumns.includes('timeElapsed')) {
              alert('CSV must include a "timeElapsed" column for Distance/Time Map');
              document.querySelector('input[name="heatmapMode"][value="incidents"]').checked = true;
              // Reset legend back
              document.getElementById('legendBar').style.background = 'linear-gradient(90deg, rgba(170,170,170,0.15), rgba(255,0,0,0.9))';
              document.getElementById('legendText').textContent = 'Gray = fewer incidents; Blue = greater incidents';
              return;
            }
            
            // Calculate distances if not already done
            if (!distanceDataCalculated) {
              document.getElementById('distanceLoadingIndicator').style.display = 'block';
              await calculateDistanceTimeRatios();
              document.getElementById('distanceLoadingIndicator').style.display = 'none';
              distanceDataCalculated = true;
            }
            
            updateShading();
          } else {
            // Update legend back to incident mode
            document.getElementById('legendBar').style.background = 'linear-gradient(90deg, rgba(170,170,170,0.15), rgba(255,0,0,0.9))';
            document.getElementById('legendText').textContent = 'Gray = fewer incidents; Blue = greater incidents';
            
            updateShading();
          }
        });
      });

      function deletePolygon(index) {
        const p = polygons[index];
        if (!p) return;
        try { if (p.layer) map.removeLayer(p.layer); } catch(e){}
        try { if (p.label) map.removeLayer(p.label); } catch(e){}
        
        // Remove from distance cache
        delete distanceCache[p.name];
        
        polygons.splice(index,1);
        savePolygonsToLocalStorage();
        saveDistanceCacheToLocalStorage();
        updatePolygonList();
        updateShading();
      }

      function updatePolygonList() {
        document.getElementById('polygonList').innerText = `Current Selection: ${polygons.length} Designated Area(s)`;
      }

      function resetAll() {
        if (!confirm('This will remove all polygons and CSV data. Continue?')) return;
        polygons.forEach(p => {
          try { map.removeLayer(p.layer); } catch(_){}
          try { map.removeLayer(p.label); } catch(_){}
        });
        polygons = [];
        csvRows = [];
        csvColumns = [];
        locationColumnName = '';
        filterableColumns = [];
        activeFilters = {};
        distanceDataCalculated = false;
        distanceCache = {};
        
        savePolygonsToLocalStorage();
        saveCsvToLocalStorage();
        saveDistanceCacheToLocalStorage();
        updatePolygonList();
        updateCsvSummary();
        updateShading();
        clearDetailsPanel();
        clearDynamicFilters();
      }

      function resetCsvDataOnly() {
        if (!confirm('Delete uploaded CSV rows but keep polygons?')) return;
        csvRows = [];
        csvColumns = [];
        locationColumnName = '';
        filterableColumns = [];
        activeFilters = {};
        distanceDataCalculated = false;
        distanceCache = {};
        
        saveCsvToLocalStorage();
        saveDistanceCacheToLocalStorage();
        updateCsvSummary();
        updateShading();
        clearDetailsPanel();
        clearDynamicFilters();
        alert('CSV data cleared.');
      }

      document.getElementById('startBtn').addEventListener('click', function () {
        drawing = true;
        polygonPoints = [];
        if (tempPolygon) map.removeLayer(tempPolygon);
        tempPolygon = null;
        this.disabled = true;
        document.getElementById('finishBtn').disabled = false;
      });

      document.getElementById('finishBtn').addEventListener('click', function () {
        drawing = false;
        this.disabled = true;
        document.getElementById('startBtn').disabled = false;
        if (polygonPoints.length < 3) {
          alert('Need at least 3 points.');
          return;
        }
        if (tempPolygon) map.removeLayer(tempPolygon);
        let polyName = prompt('Enter a name for this polygon:');
        if (!polyName) polyName = 'Unnamed Polygon';
        const finalPolygon = L.polygon(polygonPoints, { color:'blue', fillColor:'rgba(0,0,255,0.4)', weight:2 }).addTo(map);
        const polyObj = { name: polyName.trim(), coords: polygonPoints, layer: finalPolygon };
        let latSum = 0, lngSum = 0;
        polyObj.coords.forEach(c => {
          latSum += c[0];
          lngSum += c[1];
        });
        polyObj.centroid = [latSum / polyObj.coords.length, lngSum / polyObj.coords.length];
        polygons.push(polyObj);
        createLabelForPolygon(polyObj);
        savePolygonsToLocalStorage();
        updatePolygonList();
        
        // Invalidate distance calculations when new polygon added
        distanceDataCalculated = false;
        // Don't clear the entire cache, just mark as needing recalculation
        // The new polygon will be added to cache when distance mode is next activated
        
        updateShading();
      });

      map.on('click', function (e) {
        if (!drawing) return;
        polygonPoints.push([e.latlng.lat, e.latlng.lng]);
        if (tempPolygon) map.removeLayer(tempPolygon);
        tempPolygon = L.polygon(polygonPoints, { color:'red', fillColor:'rgba(255,0,0,0.3)', weight:2, dashArray:'4' }).addTo(map);
      });

      document.getElementById('setStationBtn').addEventListener('click', () => {
        alert('Click anywhere on the map to place the station marker.');
        map.once('click', function(e) {
          const latlng = e.latlng;

          if (_station && _station.marker) map.removeLayer(_station.marker);

          const marker = L.marker(latlng, { draggable: true }).addTo(map);
          marker.bindPopup('Station').openPopup();

          marker.on('dragend', () => {
            _station.latlng = marker.getLatLng();
            updateStationDisplay();
            saveStationToLocalStorage();
            
            // Invalidate distance calculations when station moved
            distanceDataCalculated = false;
            distanceCache = {};
            saveDistanceCacheToLocalStorage();
          });

          marker.on('contextmenu', () => {
            map.removeLayer(marker);
            _station = null;
            updateStationDisplay();
            saveStationToLocalStorage();
            
            // Invalidate distance calculations when station removed
            distanceDataCalculated = false;
            distanceCache = {};
            saveDistanceCacheToLocalStorage();
            updateShading();
          });

          _station = { marker, latlng };
          updateStationDisplay();
          saveStationToLocalStorage();
          
          // Invalidate distance calculations when station set
          distanceDataCalculated = false;
          distanceCache = {};
          saveDistanceCacheToLocalStorage();
        });
      });

      function parseCSV(text) {
        const lines = text.split(/\r?\n/).filter(l => l.trim() !== '');
        if (lines.length === 0) return { rows: [], columns: [], locationColumn: '', filterableColumns: [] };
        
        const headerRaw = lines[0].split(',').map(h=>h.trim());
        csvColumns = headerRaw;
        
        // Assume first column is the location column
        locationColumnName = headerRaw[0];
        
        // Determine which columns are filterable (non-numeric, non-location)
        filterableColumns = [];
        const sampleRow = lines.length > 1 ? lines[1].split(',').map(c=>c.trim()) : [];
        
        headerRaw.forEach((colName, idx) => {
          if (idx === 0) return; // Skip location column
          
          // Check if this column contains mostly numeric data
          const sampleValue = sampleRow[idx];
          if (sampleValue && !isNaN(sampleValue) && sampleValue !== '') {
            // Likely a numeric column, skip it
            return;
          }
          
          filterableColumns.push(colName);
        });

        const rows = [];
        for (let i = 1; i < lines.length; i++) {
          const cols = lines[i].split(',').map(c=>c.trim());
          if (!cols[0]) continue; // Skip if no location
          
          const rowObj = {};
          headerRaw.forEach((colName, idx) => {
            rowObj[colName] = cols[idx] || '';
          });
          
          rows.push(rowObj);
        }
        
        return { rows, columns: csvColumns, locationColumn: locationColumnName, filterableColumns };
      }

      document.getElementById('csvFile').addEventListener('change', function (ev) {
        const f = ev.target.files && ev.target.files[0];
        if (!f) return;
        const rdr = new FileReader();
        rdr.onload = function(e) {
          try {
            const parsed = parseCSV(e.target.result);
            csvRows = parsed.rows;
            csvColumns = parsed.columns;
            locationColumnName = parsed.locationColumn;
            filterableColumns = parsed.filterableColumns;
            
            // Initialize active filters
            activeFilters = {};
            filterableColumns.forEach(col => {
              activeFilters[col] = new Set();
            });
            
            // Invalidate distance calculations when new CSV loaded
            distanceDataCalculated = false;
            
            saveCsvToLocalStorage();
            buildDynamicFilters();
            updateCsvSummary();
            updateShading();
            alert(`CSV imported: ${csvRows.length} rows with ${filterableColumns.length} filterable column(s).`);
            clearDetailsPanel();
          } catch (err) {
            alert('CSV parse error: ' + err.message);
          }
        };
        rdr.readAsText(f);
        ev.target.value = '';
      });

      function buildDynamicFilters() {
        const container = document.getElementById('dynamicFiltersContainer');
        container.innerHTML = '';
        
        if (filterableColumns.length === 0) {
          container.innerHTML = '<div class="small-note">No filterable columns detected</div>';
          return;
        }
        
        // Build filters for each filterable column
        filterableColumns.forEach(colName => {
          // Create collapsible box for each filter
          const filterBox = document.createElement('div');
          filterBox.className = 'collapsible-box';
          filterBox.style.marginBottom = '8px';
          
          const filterId = `filter-${colName.replace(/\s+/g, '-')}`;
          
          const header = document.createElement('div');
          header.className = 'collapsible-header';
          header.onclick = () => toggleCollapsible(filterId);
          
          const headerTitle = document.createElement('span');
          headerTitle.textContent = colName;
          
          const headerIcon = document.createElement('span');
          headerIcon.className = 'collapse-icon collapsed';
          headerIcon.id = `${filterId}-icon`;
          headerIcon.textContent = '▼';
          
          header.appendChild(headerTitle);
          header.appendChild(headerIcon);
          filterBox.appendChild(header);
          
          const content = document.createElement('div');
          content.className = 'collapsible-content collapsed';
          content.id = `${filterId}-content`;
          
          const filtersGrid = document.createElement('div');
          filtersGrid.className = 'filters';
          
          // Get unique values for this column
          const uniqueValues = new Set();
          csvRows.forEach(row => {
            const value = row[colName];
            if (value && value.trim() !== '') {
              uniqueValues.add(value);
            }
          });
          
          // Sort values: use day-of-week order if detected, otherwise alphabetical
          const DAY_ORDER = ['M', 'T', 'W', 'Th', 'F', 'Sa', 'Su'];
          const isDayColumn = uniqueValues.size > 0 &&
            Array.from(uniqueValues).every(v => DAY_ORDER.includes(v));
          const sortedValues = isDayColumn
            ? DAY_ORDER.filter(d => uniqueValues.has(d))
            : Array.from(uniqueValues).sort();

          // Create checkbox for each unique value
          sortedValues.forEach(value => {
            const label = document.createElement('label');
            label.className = 'filter-item';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.dataset.column = colName;
            checkbox.dataset.value = value;
            
            checkbox.addEventListener('change', e => {
              if (e.target.checked) {
                activeFilters[colName].add(value);
              } else {
                activeFilters[colName].delete(value);
              }
              
              // Just update metrics if in distance mode (fast, no API calls)
              const mode = document.querySelector('input[name="heatmapMode"]:checked').value;
              if (mode === 'distance' && distanceDataCalculated) {
                updateDistanceTimeMetrics();
              }
              
              updateCsvSummary();
              updateShading();
            });
            
            label.appendChild(checkbox);
            label.appendChild(document.createTextNode(' ' + value));
            filtersGrid.appendChild(label);
          });
          
          content.appendChild(filtersGrid);
          filterBox.appendChild(content);
          container.appendChild(filterBox);
        });
      }

      function clearDynamicFilters() {
        const container = document.getElementById('dynamicFiltersContainer');
        container.innerHTML = '<div class="small-note">Upload a CSV to see available filters</div>';
        document.getElementById('csvRequirements').textContent = 'Upload a CSV file. The first column should contain location names that match those of your area selections. Include a "timeElapsed" column for distance/time analysis.';
      }

      document.getElementById('clearFiltersBtn').addEventListener('click', function () {
        // Clear all active filters
        Object.keys(activeFilters).forEach(col => {
          activeFilters[col].clear();
        });
        
        // Uncheck all checkboxes
        document.querySelectorAll('#dynamicFiltersContainer input[type="checkbox"]').forEach(cb => {
          cb.checked = false;
        });
        
        // Just update metrics if in distance mode (fast, no API calls)
        const mode = document.querySelector('input[name="heatmapMode"]:checked').value;
        if (mode === 'distance' && distanceDataCalculated) {
          updateDistanceTimeMetrics();
        }
        
        updateCsvSummary();
        updateShading();
      });

      document.getElementById('resetDataBtn').addEventListener('click', resetCsvDataOnly);

      function computeCountsForPolygons() {
        const counts = {};
        polygons.forEach(p => counts[p.name] = 0);
        if (!csvRows || csvRows.length === 0) return counts;

        csvRows.forEach(r => {
          // Check all active filters
          let passesFilters = true;
          
          for (const colName of filterableColumns) {
            const filterSet = activeFilters[colName];
            if (filterSet && filterSet.size > 0) {
              if (!filterSet.has(r[colName])) {
                passesFilters = false;
                break;
              }
            }
          }

          if (passesFilters) {
            const location = r[locationColumnName];
            if (location in counts) counts[location] += 1;
          }
        });
        
        return counts;
      }

      // OSRM API for biking routes
      async function getBikingDistance(fromLat, fromLng, toLat, toLng) {
        const url = `https://router.project-osrm.org/route/v1/bike/${fromLng},${fromLat};${toLng},${toLat}?overview=false`;
        
        try {
          const response = await fetch(url);
          const data = await response.json();
          
          if (data.routes && data.routes.length > 0) {
            return data.routes[0].distance; // Distance in meters
          }
          return null;
        } catch (error) {
          console.error('OSRM API error:', error);
          return null;
        }
      }

      async function calculateDistanceTimeRatios() {
        if (!_station || polygons.length === 0 || csvRows.length === 0) {
          return;
        }

        const stationLat = _station.latlng.lat;
        const stationLng = _station.latlng.lng;

        // Calculate distance for each polygon (only once, doesn't depend on filters)
        for (const poly of polygons) {
          // Only calculate distance if we haven't already
          if (!distanceCache[poly.name] || distanceCache[poly.name].distance === undefined) {
            // Get biking distance from station to polygon centroid
            const [polyLat, polyLng] = poly.centroid;
            const distanceMeters = await getBikingDistance(stationLat, stationLng, polyLat, polyLng);
            
            // Convert meters to miles
            const distanceMiles = distanceMeters ? distanceMeters * 0.000621371 : null;

            distanceCache[poly.name] = {
              distance: distanceMiles,
              avgTime: 0,
              ratio: 0
            };

            // Small delay to avoid overwhelming the API
            await new Promise(resolve => setTimeout(resolve, 100));
          }
        }
        
        // Now calculate time-based metrics with current filters
        updateDistanceTimeMetrics();
        
        // Save the cache to localStorage
        saveDistanceCacheToLocalStorage();
      }
      
      function updateDistanceTimeMetrics() {
        // Update time and ratio for each polygon based on current filters
        for (const poly of polygons) {
          // Get all incidents for this polygon that pass the current filters
          const incidents = csvRows.filter(r => {
            if (r[locationColumnName] !== poly.name) return false;
            
            // Check all active filters
            for (const colName of filterableColumns) {
              const filterSet = activeFilters[colName];
              if (filterSet && filterSet.size > 0) {
                if (!filterSet.has(r[colName])) {
                  return false;
                }
              }
            }
            
            return true;
          });
          
          if (incidents.length === 0 || !distanceCache[poly.name]) {
            if (distanceCache[poly.name]) {
              distanceCache[poly.name].avgTime = 0;
              distanceCache[poly.name].ratio = 0;
            }
            continue;
          }

          // Calculate average time elapsed (already in minutes)
          const totalTime = incidents.reduce((sum, incident) => {
            return sum + (parseFloat(incident.timeElapsed) || 0);
          }, 0);
          const avgTime = totalTime / incidents.length;

          const distanceMiles = distanceCache[poly.name].distance;

          // Calculate distance/time ratio (miles per minute)
          // Higher ratio = better (covers more distance per unit time)
          const ratio = avgTime > 0 && distanceMiles ? distanceMiles / avgTime : 0;

          distanceCache[poly.name].avgTime = avgTime;
          distanceCache[poly.name].ratio = ratio;
        }
      }

      function interpolateColor(c1, c2, t) {
        const r1 = parseInt(c1.slice(1,3),16), g1 = parseInt(c1.slice(3,5),16), b1 = parseInt(c1.slice(5,7),16);
        const r2 = parseInt(c2.slice(1,3),16), g2 = parseInt(c2.slice(3,5),16), b2 = parseInt(c2.slice(5,7),16);
        const r = Math.round(r1 + (r2 - r1) * t);
        const g = Math.round(g1 + (g2 - g1) * t);
        const b = Math.round(b1 + (b2 - b1) * t);
        return `rgb(${r},${g},${b})`;
      }

      function updateShading() {
        const mode = document.querySelector('input[name="heatmapMode"]:checked').value;
        
        if (mode === 'distance') {
          // Distance/time mode
          if (!distanceDataCalculated || Object.keys(distanceCache).length === 0) {
            // Not calculated yet, show neutral
            polygons.forEach(p => {
              p.layer.setStyle({ color: '#aaaaaa', fillColor: '#aaaaaa', fillOpacity: 0.4, weight: 2 });
            });
            
            // Trigger recalculation if we have station and data
            if (_station && csvRows.length > 0 && polygons.length > 0) {
              document.getElementById('distanceLoadingIndicator').style.display = 'block';
              calculateDistanceTimeRatios().then(() => {
                document.getElementById('distanceLoadingIndicator').style.display = 'none';
                distanceDataCalculated = true;
                updateShading(); // Recursively call to apply the new colors
              });
            }
            return;
          }

          // Calculate average ratio from cached data
          const ratios = Object.values(distanceCache).map(d => d.ratio).filter(r => r > 0);
          if (ratios.length === 0) {
            polygons.forEach(p => {
              p.layer.setStyle({ color: '#aaaaaa', fillColor: '#aaaaaa', fillOpacity: 0.4, weight: 2 });
            });
            return;
          }

          const avgRatio = ratios.reduce((sum, r) => sum + r, 0) / ratios.length;
          const maxRatio = Math.max(...ratios);
          const minRatio = Math.min(...ratios);

          polygons.forEach(p => {
            const data = distanceCache[p.name];
            if (!data || data.ratio === 0) {
              p.layer.setStyle({ color: '#aaaaaa', fillColor: '#aaaaaa', fillOpacity: 0.4, weight: 2 });
              return;
            }

            // Normalize ratio from min to max
            // Lowest ratio = most blue (worst/slowest)
            // Highest ratio = most green (best/fastest)
            let color, opacity;
            
            const range = maxRatio - minRatio;
            if (range > 0) {
              const normalizedValue = (data.ratio - minRatio) / range; // 0 to 1
              // 0 = blue (worst), 1 = green (best)
              color = interpolateColor('#ff00000', '#00ff00', normalizedValue);
              opacity = 0.5 + (normalizedValue * 0.4); // 0.5 to 0.9
            } else {
              // All ratios are the same
              color = '#00ff00';
              opacity = 0.7;
            }

            p.layer.setStyle({
              color: color,
              fillColor: color,
              fillOpacity: opacity,
              weight: 2
            });
          });

          updateCsvSummary();
          return;
        }

        // Incident count mode
        const counts = computeCountsForPolygons();
        let max = 0;
        Object.values(counts).forEach(v => { if (v>max) max=v; });
        
        polygons.forEach(p => {
          const c = counts[p.name] || 0;
          const ratio = max > 0 ? c / max : 0;
          const boosted = Math.pow(ratio, 0.55);
          const opacity = 0.45 + boosted * 0.55;

          const fillColor = interpolateColor("#aaaaaa", "#0000ff", boosted);

          p.layer.setStyle({
            color: fillColor,
            fillColor: fillColor,
            fillOpacity: opacity,
            weight: 2
          });
        });
        
        updateCsvSummary();
      }

      function updateCsvSummary() {
        const el = document.getElementById('csvSummary');
        const mode = document.querySelector('input[name="heatmapMode"]:checked').value;
        
        if (!csvRows || csvRows.length === 0) {
          el.innerText = 'No CSV loaded';
          return;
        }

        if (mode === 'distance' && distanceDataCalculated) {
          // Show distance/time ratio rankings
          const ratioEntries = Object.entries(distanceCache)
            .filter(([name, data]) => data.ratio > 0)
            .map(([name, data]) => ({ name, ratio: data.ratio, avgTime: data.avgTime }))
            .sort((a, b) => b.ratio - a.ratio); // Highest to lowest
          
          if (ratioEntries.length === 0) {
            el.innerText = 'No distance/time data available';
            return;
          }
          
          if (ratioEntries.length <= 6) {
            // Show all if 6 or fewer
            const lines = ratioEntries.map(e => `${e.name}: ${e.ratio.toFixed(3)} mi/min (${e.avgTime.toFixed(1)} min)`);
            el.innerText = `Efficiency Rankings:\n${lines.join('\n')}`;
          } else {
            // Show top 3 and bottom 3
            const top3 = ratioEntries.slice(0, 3);
            const bottom3 = ratioEntries.slice(-3).reverse();
            
            const topLines = top3.map(e => `✓ ${e.name}: ${e.ratio.toFixed(3)} mi/min (${e.avgTime.toFixed(1)} min)`);
            const bottomLines = bottom3.map(e => `✗ ${e.name}: ${e.ratio.toFixed(3)} mi/min (${e.avgTime.toFixed(1)} min)`);
            
            el.innerText = `Top 3 Fastest:\n${topLines.join('\n')}\n\nBottom 3 Slowest:\n${bottomLines.join('\n')}`;
          }
          return;
        }

        // Incident count mode
        let totalActive = 0, matched = 0, unmatched = 0;
        const namesSet = new Set(polygons.map(p=>p.name));

        csvRows.forEach(r => {
          let passesFilters = true;
          
          for (const colName of filterableColumns) {
            const filterSet = activeFilters[colName];
            if (filterSet && filterSet.size > 0) {
              if (!filterSet.has(r[colName])) {
                passesFilters = false;
                break;
              }
            }
          }

          if (passesFilters) {
            totalActive++;
            if (namesSet.has(r[locationColumnName])) matched++;
            else unmatched++;
          }
        });

        const counts = computeCountsForPolygons();
        const entries = Object.entries(counts).sort((a,b)=>b[1]-a[1]);
        const lines = entries.slice(0,3).map(e=>`${e[0]}: ${e[1]}`);
        const more = entries.length>3 ? `\n+ ${entries.length-3} more...` : '';

        el.innerText = `Top Incident Locations:\n${lines.join('\n')}${more}`;
      }

      function showPolygonPopup(poly) {
        const matches = csvRows.filter(r => r[locationColumnName] === poly.name);
        
        // Build popup content
        let popupHTML = `<div class="poly-popup">`;
        popupHTML += `<div class="popup-title">${poly.name}</div>`;
        popupHTML += `<div style="font-size:14px; color:#6b7280; margin-bottom:10px;">Total Incidents: ${matches.length}</div>`;
        
        // Show distance/time data if in distance mode
        const mode = document.querySelector('input[name="heatmapMode"]:checked').value;
        if (mode === 'distance' && distanceCache[poly.name]) {
          const data = distanceCache[poly.name];
          popupHTML += `<div style="font-size:14px; background:#f0f9ff; padding:6px; border-radius:4px; margin-bottom:10px;">`;
          popupHTML += `<div><strong>Avg Time:</strong> ${data.avgTime ? data.avgTime.toFixed(1) + ' min' : 'N/A'}</div>`;
          popupHTML += `<div><strong>Efficiency:</strong> ${data.ratio ? data.ratio.toFixed(3) + ' mi/min' : 'N/A'}</div>`;
          popupHTML += `</div>`;
        }
        
        if (matches.length === 0) {
          popupHTML += `<div style="color:#9ca3af; font-size:12px;">No incidents found</div>`;
          popupHTML += `</div>`;
          poly.layer.bindPopup(popupHTML, { maxWidth: 300, maxHeight: 300 }).openPopup();
          return;
        }
        
        // Count incidents by each filterable column
        filterableColumns.forEach(colName => {
          const valueCounts = {};
          matches.forEach(row => {
            const val = row[colName] || '(empty)';
            valueCounts[val] = (valueCounts[val] || 0) + 1;
          });
          
          const sectionId = `popup-section-${poly.name}-${colName}`.replace(/\s+/g, '-');
          const bodyId = `popup-body-${poly.name}-${colName}`.replace(/\s+/g, '-');
          
          popupHTML += `<div class="popup-section">`;
          popupHTML += `<div class="popup-section-header" onclick="togglePopupSection('${bodyId}')">`;
          popupHTML += `<span>${colName}</span>`;
          popupHTML += `<span style="color:#6b7280;">▼</span>`;
          popupHTML += `</div>`;
          popupHTML += `<div class="popup-section-body" id="${bodyId}" style="display:none;">`;
          
          Object.entries(valueCounts).sort((a,b) => b[1] - a[1]).forEach(([val, count]) => {
            popupHTML += `<div style="padding:3px 0;">${val}: <strong>${count}</strong></div>`;
          });
          
          popupHTML += `</div></div>`;
        });
        
        // Complete list of incidents (expandable)
        const listBodyId = `popup-list-${poly.name}`.replace(/\s+/g, '-');
        popupHTML += `<div class="popup-section">`;
        popupHTML += `<div class="popup-section-header" onclick="togglePopupSection('${listBodyId}')">`;
        popupHTML += `<span>All Incidents</span>`;
        popupHTML += `<span style="color:#6b7280;">▼</span>`;
        popupHTML += `</div>`;
        popupHTML += `<div class="popup-section-body" id="${listBodyId}" style="display:none;">`;
        popupHTML += `<div class="popup-table-wrapper">`;
        popupHTML += `<table style="width:100%; font-size:11px; border-collapse:collapse;">`;
        popupHTML += `<thead><tr>`;
        
        csvColumns.forEach(col => {
          popupHTML += `<th style="border-bottom:1px solid #e5e7eb; padding:4px; text-align:left; white-space:nowrap;">${col}</th>`;
        });
        
        popupHTML += `</tr></thead><tbody>`;
        
        matches.forEach(row => {
          popupHTML += `<tr>`;
          csvColumns.forEach(col => {
            popupHTML += `<td style="border-bottom:1px solid #f3f4f6; padding:4px; white-space:nowrap;">${row[col] || ''}</td>`;
          });
          popupHTML += `</tr>`;
        });
        
        popupHTML += `</tbody></table></div></div></div>`;
        popupHTML += `</div>`;
        
        poly.layer.bindPopup(popupHTML, { maxWidth: 300, maxHeight: 300 }).openPopup();
      }
      
      // Global function to toggle popup sections (needs to be in window scope for onclick)
      window.togglePopupSection = function(bodyId) {
        const body = document.getElementById(bodyId);
        if (body) {
          body.style.display = body.style.display === 'none' ? 'block' : 'none';
        }
      };

      function showAllRowsAndSummaryForPolygon(name) {
        const tb = document.getElementById('detailsTbody');
        const thead = document.getElementById('detailsTableHead').querySelector('tr');
        const scroll = document.getElementById('detailsScroll');
        const summaryContainer = document.getElementById('summaryContainer');

        tb.innerHTML = '';
        thead.innerHTML = '';
        summaryContainer.innerHTML = '';

        const matches = csvRows.filter(r => r[locationColumnName] === name);

        if (matches.length === 0) {
          scroll.style.display = 'none';
          summaryContainer.style.display = 'none';
          return;
        }

        scroll.style.display = 'block';

        // Build table headers from CSV columns
        csvColumns.forEach(col => {
          const th = document.createElement('th');
          th.textContent = col;
          thead.appendChild(th);
        });

        // Build table rows
        const tbodyFrag = document.createDocumentFragment();
        matches.forEach(row => {
          const tr = document.createElement('tr');
          csvColumns.forEach(col => {
            const td = document.createElement('td');
            td.textContent = row[col] || '';
            tr.appendChild(td);
          });
          tbodyFrag.appendChild(tr);
        });
        tb.appendChild(tbodyFrag);

        // Build summary if there are filterable columns
        if (filterableColumns.length > 0) {
          summaryContainer.style.display = 'block';
          
          filterableColumns.forEach(colName => {
            const valueCounts = {};
            matches.forEach(row => {
              const val = row[colName] || '(empty)';
              valueCounts[val] = (valueCounts[val] || 0) + 1;
            });

            const section = document.createElement('div');
            section.className = 'day-section';

            const header = document.createElement('div');
            header.className = 'day-header';
            header.innerHTML = `<div class="day-title">${colName}</div><div class="muted">Total: ${matches.length}</div>`;
            section.appendChild(header);

            const body = document.createElement('div');
            body.className = 'day-body';
            
            Object.entries(valueCounts).sort((a,b) => b[1] - a[1]).forEach(([val, count]) => {
              const line = document.createElement('div');
              line.className = 'shift-line';
              line.innerText = `${val}: ${count}`;
              body.appendChild(line);
            });
            
            section.appendChild(body);

            header.addEventListener('click', () => {
              body.style.display = body.style.display === 'block' ? 'none' : 'block';
            });

            summaryContainer.appendChild(section);
          });
        }
      }

      function clearDetailsPanel() {
        document.getElementById('detailsTbody').innerHTML = '';
        document.getElementById('detailsTableHead').querySelector('tr').innerHTML = '';
        document.getElementById('detailsScroll').style.display = 'none';
        document.getElementById('summaryContainer').innerHTML = '';
        document.getElementById('summaryContainer').style.display = 'none';
      }

      function exportPolygonsToFile() {
        try {
          const payload = polygons.map(p => ({ name: p.name, coords: p.coords }));
          const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'mapping_area_designations.json';
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
        } catch (err) {
          alert('Export failed: ' + (err && err.message ? err.message : err));
        }
      }

      function importPolygonsFromFile(file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            const data = JSON.parse(e.target.result);
            if (!Array.isArray(data)) throw new Error('Invalid format');

            polygons.forEach(p => {
              try { if (p.layer) map.removeLayer(p.layer); } catch(_) {}
              try { if (p.label) map.removeLayer(p.label); } catch(_) {}
            });
            polygons = [];

            data.forEach(item => {
              const layer = L.polygon(item.coords, { color:'blue', fillColor:'rgba(0,0,255,0.4)', weight:2 }).addTo(map);
              const polyObj = { name: item.name, coords: item.coords, layer };
              polygons.push(polyObj);
              createLabelForPolygon(polyObj);
            });

            savePolygonsToLocalStorage();
            updatePolygonList();
            
            // Invalidate distance calculations when polygons imported
            distanceDataCalculated = false;
            distanceCache = {};
            saveDistanceCacheToLocalStorage();
            
            updateShading();
            clearDetailsPanel();
          } catch (err) {
            alert('Import failed: ' + (err && err.message ? err.message : err));
          }
        };
        reader.readAsText(file);
      }

      document.getElementById('exportPolygonsBtn').addEventListener('click', exportPolygonsToFile);
      document.getElementById('importPolygonsFile').addEventListener('change', function(ev) {
        const f = ev.target.files && ev.target.files[0];
        if (!f) return;
        importPolygonsFromFile(f);
        ev.target.value = '';
      });

      document.getElementById('resetBtn').addEventListener('click', resetAll);

      // Initialize
      loadCsvFromLocalStorage();
      loadPolygonsFromLocalStorage();
      loadStationFromLocalStorage(); // Load saved station
      loadDistanceCacheFromLocalStorage(); // Load saved distance cache
      updateShading();
      clearDetailsPanel();
      updateMapCenterDisplay();

      window._polyApp = { polygons, csvRows, updateShading, resetAll, resetCsvDataOnly, distanceCache };
    </script>
  </body>
</html>
