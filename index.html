<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>The EMS Mapping Project - Enhanced</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

    <style>
      :root {
        --sidebar-w: 360px;
        --muted: #666;
        --accent: #0b66ff;
      }

      html, body {
        height: 100%;
        margin: 0;
        font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
        font-size: 13px;
      }

      #sidebar {
        position: absolute;
        top: 0;
        left: 0;
        width: var(--sidebar-w);
        height: 100vh;
        background: #fff;
        border-right: 1px solid #e6e9ee;
        padding: 12px;
        box-sizing: border-box;
        overflow-y: auto;
        z-index: 999;
      }

      #map {
        position: absolute;
        left: var(--sidebar-w);
        top: 0;
        width: calc(100vw - var(--sidebar-w));
        height: 100vh;
      }

      .controls-row { display:flex; gap:8px; }
      button, input[type="file"] {
        display: block;
        width: 100%;
        padding: 8px 10px;
        margin-top: 8px;
        box-sizing: border-box;
        border-radius: 6px;
        border: 1px solid #cfd6df;
        background: #f7f9fb;
        cursor: pointer;
      }
      button:disabled { opacity: 0.6; cursor: not-allowed; }

      .section-title {
        margin-top: 14px;
        font-weight: 600;
        font-size: 14px;
      }

      .small-note { color: var(--muted); font-size: 12px; }

      .filters { display:grid; grid-template-columns:repeat(3,1fr); gap:6px; margin-top:8px; }

      label.filter-item { display:inline-flex; align-items:center; gap:6px; cursor:pointer; user-select:none; font-size:13px; }

      .legend { margin-top:12px; }
      .legend-bar { height: 14px; border-radius:4px; margin-top:6px; }

      .counts { margin-top:8px; font-size:13px; color:#111827; white-space:pre-wrap; }

      .polygon-details { margin-top:12px; border-top:1px dashed #e6e9ee; padding-top:10px; }

      .details-title { display:flex; justify-content:space-between; align-items:center; gap:10px; }

      .details-scroll { max-height: 220px; overflow:auto; margin-top:8px; border:1px solid #f1f3f5; border-radius:6px; }

      .details-table { width:100%; border-collapse:collapse; margin-top:8px; }
      .details-table th, .details-table td { border:1px solid #e6e9ee; padding:6px 8px; font-size:13px; text-align:left; }

      .summary-block { margin-top:10px; font-size:13px; }
      .day-section { border:1px solid #eef2f6; border-radius:6px; margin-top:8px; overflow:hidden; }
      .day-header { display:flex; justify-content:space-between; align-items:center; padding:8px 10px; cursor:pointer; background:#fafbfc; }
      .day-title { font-weight:600; }
      .day-body { padding:8px 12px; display:none; background:#fff; }
      .shift-line { margin-left:8px; font-size:13px; color:#111827; }
      .muted { color:var(--muted); }

      .poly-label { background: rgba(255,255,255,0.95); padding:4px 8px; border-radius:6px; border:1px solid #cbd5e1; font-size:13px; color:#0f172a; box-shadow: 0 1px 2px rgba(0,0,0,0.06); }
      
      .category-label { background: rgba(255,215,0,0.95); padding:4px 8px; border-radius:6px; border:1px solid #d4a017; font-size:13px; font-weight:600; color:#0f172a; box-shadow: 0 1px 2px rgba(0,0,0,0.06); }

      .top-controls { display:flex; gap:8px; margin-bottom:6px; }
      
      .poly-popup {
        min-width: 300px;
        max-width: 300px;
        max-height: 300px;
        overflow-y: auto;
        font-family: inherit;
      }
      
      .popup-table-wrapper {
        overflow-x: auto;
        max-width: 100%;
      }
      
      .popup-title {
        font-weight: 600;
        font-size: 14px;
        margin-bottom: 8px;
        padding-bottom: 6px;
        border-bottom: 2px solid #e5e7eb;
      }
      
      .popup-section {
        margin-top: 10px;
        border: 1px solid #e5e7eb;
        border-radius: 6px;
        overflow: hidden;
      }
      
      .popup-section-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 10px;
        background: #f9fafb;
        cursor: pointer;
        font-size: 13px;
        font-weight: 600;
      }
      
      .popup-section-header:hover {
        background: #f3f4f6;
      }
      
      .popup-section-body {
        padding: 8px 10px;
        font-size: 12px;
        background: #fff;
      }
      
      .filter-section {
        margin-top: 12px;
        padding: 10px;
        background: #f9fafb;
        border-radius: 6px;
        border: 1px solid #e5e7eb;
      }
      
      .filter-section-title {
        font-weight: 600;
        margin-bottom: 6px;
        font-size: 13px;
      }

      .loading-indicator {
        color: #0b66ff;
        font-size: 12px;
        font-style: italic;
        margin-top: 8px;
      }

      .collapsible-box {
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        margin-bottom: 12px;
        background: #fff;
        overflow: hidden;
      }

      .collapsible-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 12px;
        background: #f9fafb;
        cursor: pointer;
        font-weight: 600;
        font-size: 14px;
        user-select: none;
      }

      .collapsible-header:hover {
        background: #f3f4f6;
      }

      .collapsible-content {
        padding: 12px;
        background: #fff;
      }

      .collapsible-content.collapsed {
        display: none;
      }

      .collapse-icon {
        color: #6b7280;
        font-size: 12px;
        transition: transform 0.2s;
      }

      .collapse-icon.collapsed {
        transform: rotate(-90deg);
      }

      .subsection-title {
        font-weight: 600;
        font-size: 13px;
        margin-top: 12px;
        margin-bottom: 6px;
        color: #374151;
      }

      .subsection-title:first-child {
        margin-top: 0;
      }

      .map-overlay-text {
        position: absolute;
        bottom: 20px;
        left: calc(var(--sidebar-w) + 20px);
        right: 20px;
        background: rgba(255, 255, 255, 0.95);
        padding: 12px 16px;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        z-index: 1000;
        font-size: 14px;
        color: #374151;
        border: 1px solid #e5e7eb;
        pointer-events: none;
      }
      
      .location-checkbox-list {
        max-height: 200px;
        overflow-y: auto;
        margin-top: 8px;
        border: 1px solid #e5e7eb;
        border-radius: 6px;
        padding: 8px;
        background: #fafbfc;
      }
      
      .location-checkbox-item {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 4px;
        font-size: 13px;
      }
      
      .category-mode-banner {
        background: #fef3c7;
        border: 2px solid #fbbf24;
        padding: 10px;
        border-radius: 6px;
        margin-bottom: 10px;
        font-weight: 600;
        color: #92400e;
        text-align: center;
      }

      .undo-hint {
        font-size: 11px;
        color: #6b7280;
        font-style: italic;
        margin-top: 4px;
      }
    </style>
  </head>

  <body>
    <div id="sidebar">
      
      <!-- Category Mode Banner -->
      <div id="categoryModeBanner" class="category-mode-banner" style="display:none;">
        üìÅ CATEGORY MODE ACTIVE
      </div>
      
      <div class="collapsible-box" style="margin-top: 10px;">
        <div class="collapsible-header" onclick="toggleCollapsible('needHelp')" style="background:#deab3490">
          <span style="color:#1b3907;">Help and How-Tos!</span>
          <span class="collapse-icon collapsed" id="needHelp-icon">‚ñº</span>
        </div>
        <div class="collapsible-content collapsed" id="needHelp-content" style="background:#deab3431">
          
          <div class="subsection-title" style="margin-bottom:3px; font-size: 14px;">1. Map Center</div>
          <div style="font-size:13px;">This is roughly where your university/operational area is located. You may use the 'Set Map Center' button to search for another area. The 'Default' location is set to The University of Texas at Dallas (Whoosh!) with a zoom factor of 16.</div>
          <hr style="border: none; border-top: 2px solid #1b3907; margin: 12px 0;" />
          
          <div class="subsection-title" style="margin-bottom:3px; font-size: 14px;">2. Station Location</div>
          <div style="font-size:13px;">You only need to use this feature if you choose to make use of the Distance/Time mapping feature. To move the station marker, simply drag the pin to the desired location. To delete the station marker, right click the pin.</div>
          <hr style="border: none; border-top: 2px solid #1b3907; margin: 12px 0;" />
          
          <div class="subsection-title" style="font-size: 14px;">3. Upload Incident Data</div>
          <div style="font-size:13px;">Upload your agency's incident data as a .CSV file. Include a 'timeElapsed' column for Distance/Time mapping.</div>
          
          <hr style="border: none; border-top: 2px solid #1b3907; margin: 12px 0;" />
          <div class="subsection-title" style="margin-bottom: 3px; font-size:14px;">4. Area Selection Tool</div>
          <div style="font-size:13px;">
          This feature allows you to designate specific areas that you want to observe trends with.
          <ul style="margin-top:3px;">
              <li><strong>To create areas:</strong> Click 'Start New Area', then click on the map to create points. <strong>Drag the larger circles</strong> to adjust point positions. Click 'Finish' to save.</li>
              <li><strong>To undo a point:</strong> Press <strong>Ctrl+Z</strong> (or Cmd+Z on Mac) to remove the last point added.</li>
              <li><strong>To delete an area:</strong> Right click anywhere within its bounds.</li>
              <li><strong>To export areas:</strong> Click the 'Export' button.</li>
          </ul>
          </div>
          <hr style="border: none; border-top: 2px solid #1b3907; margin: 12px 0;" />
          
          <div class="subsection-title" style="margin-bottom: 3px; font-size:14px;">5. Category Creation</div>
          <div style="font-size:13px;">
          Categories allow you to group multiple locations from your CSV under a single custom area.
          <ul style="margin-top:3px;">
              <li>Enable Category Mode and click 'Start New Category'</li>
              <li>Draw a polygon area on the map</li>
              <li>Select which CSV locations should be included</li>
              <li>Categories aggregate metrics: numeric values are summed, timeElapsed is averaged</li>
              <li>Categories are displayed with gold labels</li>
          </ul>
          </div>
          
        </div>
      </div>
      
      <div class="collapsible-box">
        <div class="collapsible-header" onclick="toggleCollapsible('mapSettings')" style="background:#83be5c">
          <span style="color:#1b3907;">Map Settings and File Uploads</span>
          <span class="collapse-icon" id="mapSettings-icon">‚ñº</span>
        </div>
        <div class="collapsible-content" id="mapSettings-content" style="background:#83be5c22">
          
          <div class="subsection-title" style="margin-bottom:0px; font-size: 14px;">1. Map Center Coordinates</div>
          <div class="controls-row">
            <button id="setMapCenterBtn" style="background:#83be5cb1;color:#1b3907">Set Map Center</button>
            <button id="resetMapCenterBtn" style="background:#83be5cb1;color:#1b3907">Reset to Default</button>
          </div>
          <div id="mapCenterCoords" class="small-note" style="margin-top:6px; margin-bottom:10px">Default: Lat 32.985, Lng -96.75, Zoom 16</div>
          <hr style="border: none; border-top: 2px solid #1b3907; margin: 12px 0;" />
          
          <div class="subsection-title" style="font-size:14px">2. Station Location</div>
          <button id="setStationBtn" style="background:#83be5cb1;color:#1b3907;">Set Station</button>
          <div id="stationCoords" class="small-note" style="margin-top:6px;">Station not set (required for Distance/Time Map)</div>
          <hr style="border: none; border-top: 2px solid #1b3907; margin: 12px 0;" />
          
          <div class="subsection-title" style="margin-bottom: 0px;font-size:14px">3. Area Selection Tool</div>
          <div class="controls-row">
            <button id="startBtn" style="background:#83be5cb1;color:#1b3907">Start New Area</button>
            <button id="finishBtn" disabled style="background:#83be5cb1;color:#1b3907">Finish</button>
            <button id="exportPolygonsBtn" style="background:#83be5cb1;color:#1b3907">Export Areas</button>
          </div>
          <div class="undo-hint">üí° Tip: Press Ctrl+Z to undo last point</div>
          <div class="subsection-title" style="text-indent: 10px; font-size:14px">Or Upload Areas</div>
          <input id="importPolygonsFile" type="file" accept=".json" style="margin-top:8px; margin-left:10px; width: calc(100% - 10px); background:#83be5c58;color:#1b3907" />
          <div class="small-note" style="margin-top:6px; margin-left:10px; font-style: italic; color:#635886b1">Upload a .JSON file here.</div>
          <hr style="border: none; border-top: 2px solid #1b3907; margin: 12px 0;" />
          
          <div class="subsection-title" style="font-size:14px">4. Category Creation</div>
          <label class="filter-item" style="margin-bottom:8px; font-weight: 600;">
            <input type="checkbox" id="categoryModeToggle" /> Enable Category Mode
          </label>
          <div id="categoryModeControls" style="display:none;">
            <button id="startCategoryBtn" style="background:#fbbf24;color:#1b3907">Start New Category</button>
            <button id="finishCategoryBtn" disabled style="background:#fbbf24;color:#1b3907">Finish Category</button>
            <div class="undo-hint">üí° Tip: Press Ctrl+Z to undo last point</div>
            <div id="locationSelectionContainer" style="display:none; margin-top:10px;">
              <div style="font-weight:600; margin-bottom:6px;">Select Locations for Category:</div>
              <div id="locationCheckboxList" class="location-checkbox-list"></div>
            </div>
          </div>
          <hr style="border: none; border-top: 2px solid #1b3907; margin: 12px 0;" />
          
          <div class="subsection-title" style="font-size:14px">5. Upload Incident Data</div>
          <input id="csvFile" type="file" accept=".csv,text/csv" style="margin-top:0; background:#83be5c58;color:#1b3907" />
          <div class="small-note" style="margin-top:6px; font-style: italic; color:#635886b1">Upload a .CSV file. First column should contain location IDs matching your areas. Include "timeElapsed" column for Distance/Time analysis.</div>
          <button id="resetDataBtn" style="margin-top:8px;background:#83be5cb1;color:#1b3907">Clear Incident Data Only</button>
          <hr style="border: none; border-top: 2px solid #1b3907; margin: 12px 0;" />
          
          <button id="resetBtn" style="background:#2e5315ee;color:#ffffff">Reset All</button>
          <div id="polygonList" class="counts muted" style="margin-top:6px; text-align:center; font-weight:500; color:#1b390798">0 Saved Area(s)</div>
        </div>
      </div>

      <label class="filter-item" style="margin-bottom:12px; font-weight: 600;">
        <input type="checkbox" id="toggleLabels" checked /> Toggle Area Labels
      </label>

      <div class="section-title">Heatmap Mode</div>
      <label class="filter-item">
        <input type="radio" name="heatmapMode" value="incidents" checked /> Incident Count
      </label>
      <label class="filter-item">
        <input type="radio" name="heatmapMode" value="distance" /> Distance/Time Map
      </label>
      <div id="distanceLoadingIndicator" class="loading-indicator" style="display:none;">Calculating distances...</div>

      <div class="section-title" style="margin-bottom: 15px;">Filter Selections</div>
      <div id="dynamicFiltersContainer">
        <div class="small-note">Upload a CSV to see available filters</div>
      </div>
      <div style="margin-top:12px; display:flex; gap:8px;">
        <button id="clearFiltersBtn" style="background:#d7d7d79b">Clear Filters</button>
      </div>

      <div class="legend">
        <div style="font-weight:600">Legend</div>
        <div class="legend-bar" id="legendBar" style="background: linear-gradient(90deg, rgba(91, 91, 91, 0.15), rgba(0,0,255,0.9));"></div>
        <div class="small-note" id="legendText">Gray = fewer incidents; Blue = greater incidents</div>
      </div>

      <div class="section-title">Broad Summary</div>
      <div id="csvSummary" class="counts muted">No CSV loaded</div>

      <div id="summaryContainer" class="summary-block" style="display:none;"></div>
      
      <div class="details-scroll" id="detailsScroll" style="display:none;">
        <table class="details-table" id="detailsTable">
          <thead id="detailsTableHead">
            <tr></tr>
          </thead>
          <tbody id="detailsTbody"></tbody>
        </table>
      </div>
    </div>

    <div id="map"></div>
    
    <div class="map-overlay-text" style="text-align: center;">
      Created by Priya Darbha, Roshan Ahmed, and Divya Arivalagan. University of Texas at Dallas - University Emergency Medical Response, c. 2026
    </div>

    <script>
      function toggleCollapsible(sectionId) {
        const content = document.getElementById(sectionId + '-content');
        const icon = document.getElementById(sectionId + '-icon');
        
        if (content.classList.contains('collapsed')) {
          content.classList.remove('collapsed');
          icon.classList.remove('collapsed');
        } else {
          content.classList.add('collapsed');
          icon.classList.add('collapsed');
        }
      }

      const DEFAULT_MAP_CENTER = { lat: 32.985962, lng: -96.750402, zoom: 16 };
      const LS_MAP_CENTER = 'map_center_v1';
      
      let mapCenter = DEFAULT_MAP_CENTER;
      try {
        const saved = localStorage.getItem(LS_MAP_CENTER);
        if (saved) {
          mapCenter = JSON.parse(saved);
        }
      } catch (e) {}
      
      const map = L.map('map').setView([mapCenter.lat, mapCenter.lng], mapCenter.zoom);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

      let drawing = false;
      let polygonPoints = [];
      let tempPolygon = null;
      let tempMarkers = [];
      let polygons = [];
      let csvRows = [];
      let _station = null;
      let activeRouteLine = null;

      let csvColumns = [];
      let locationColumnName = '';
      let filterableColumns = [];
      let activeFilters = {};
      
      let categoryMode = false;
      let selectedLocations = new Set();

      let distanceDataCalculated = false;
      let distanceCache = {};

      // NEW: Flag to prevent click events immediately after dragging
      let justFinishedDragging = false;

      const LS_POLYGONS = 'polygons_v4';
      const LS_CSV = 'polygons_csv_rows_v4';
      const LS_STATION = 'station_location_v1';
      const LS_DISTANCE_CACHE = 'distance_cache_v1';

      // NEW: Keyboard shortcut handler for Ctrl+Z / Cmd+Z
      document.addEventListener('keydown', function(e) {
        // Check for Ctrl+Z (Windows/Linux) or Cmd+Z (Mac)
        if ((e.ctrlKey || e.metaKey) && e.key === 'z' && drawing && polygonPoints.length > 0) {
          e.preventDefault();
          undoLastPoint();
        }
      });

      function undoLastPoint() {
        if (!drawing || polygonPoints.length === 0) return;
        
        // Remove the last point
        polygonPoints.pop();
        
        // Remove the last marker
        const lastMarker = tempMarkers.pop();
        if (lastMarker) {
          map.removeLayer(lastMarker);
          if (lastMarker._handleMove) map.off('mousemove', lastMarker._handleMove);
          if (lastMarker._handleUp) map.off('mouseup', lastMarker._handleUp);
        }
        
        // Update indices for remaining markers
        tempMarkers.forEach((m, i) => {
          m._pointIndex = i;
        });
        
        // Redraw the temp polygon
        updateTempPolygon();
      }

      function saveStationToLocalStorage() {
        try {
          if (_station && _station.latlng) {
            localStorage.setItem(LS_STATION, JSON.stringify({
              lat: _station.latlng.lat,
              lng: _station.latlng.lng
            }));
          } else {
            localStorage.removeItem(LS_STATION);
          }
        } catch (e) {}
      }

      function saveDistanceCacheToLocalStorage() {
        try {
          if (Object.keys(distanceCache).length > 0) {
            localStorage.setItem(LS_DISTANCE_CACHE, JSON.stringify({
              cache: distanceCache,
              calculated: distanceDataCalculated
            }));
          } else {
            localStorage.removeItem(LS_DISTANCE_CACHE);
          }
        } catch (e) {}
      }

      function loadDistanceCacheFromLocalStorage() {
        try {
          const raw = localStorage.getItem(LS_DISTANCE_CACHE);
          if (!raw) return;
          
          const data = JSON.parse(raw);
          if (data.cache && typeof data.cache === 'object') {
            distanceCache = data.cache;
            distanceDataCalculated = data.calculated || false;
          }
        } catch (e) {}
      }

      function loadStationFromLocalStorage() {
        try {
          const raw = localStorage.getItem(LS_STATION);
          if (!raw) return;
          
          const data = JSON.parse(raw);
          if (!data.lat || !data.lng) return;
          
          const latlng = L.latLng(data.lat, data.lng);
          const marker = L.marker(latlng, { draggable: true }).addTo(map);
          marker.bindPopup('Station');
          
          marker.on('dragend', () => {
            _station.latlng = marker.getLatLng();
            updateStationDisplay();
            saveStationToLocalStorage();
            
            distanceDataCalculated = false;
            distanceCache = {};
            saveDistanceCacheToLocalStorage();
          });

          marker.on('contextmenu', () => {
            map.removeLayer(marker);
            _station = null;
            updateStationDisplay();
            saveStationToLocalStorage();
            
            distanceDataCalculated = false;
            distanceCache = {};
            saveDistanceCacheToLocalStorage();
            updateShading();
          });

          _station = { marker, latlng };
          updateStationDisplay();
        } catch (e) {}
      }

      function updateStationDisplay() {
        const display = document.getElementById('stationCoords');
        if (_station && _station.latlng) {
          display.innerText = `Lat: ${_station.latlng.lat.toFixed(6)}, Lng: ${_station.latlng.lng.toFixed(6)}`;
        } else {
          display.innerText = 'Station not set (required for Distance/Time Map)';
        }
      }

      function updateMapCenterDisplay() {
        const display = document.getElementById('mapCenterCoords');
        if (mapCenter.lat === DEFAULT_MAP_CENTER.lat && 
            mapCenter.lng === DEFAULT_MAP_CENTER.lng && 
            mapCenter.zoom === DEFAULT_MAP_CENTER.zoom) {
          display.textContent = `Default: Lat ${mapCenter.lat}, Lng ${mapCenter.lng}, Zoom ${mapCenter.zoom}`;
        } else {
          display.textContent = `Custom: Lat ${mapCenter.lat.toFixed(6)}, Lng ${mapCenter.lng.toFixed(6)}, Zoom ${mapCenter.zoom}`;
        }
      }

      document.getElementById('setMapCenterBtn').addEventListener('click', () => {
        const currentCenter = map.getCenter();
        const currentZoom = map.getZoom();
        
        const input = prompt(
          `Enter coordinates and zoom level:\n\n` +
          `Format: latitude, longitude, zoom\n` +
          `Example: 32.985, -96.75, 16\n\n` +
          `Current: ${currentCenter.lat.toFixed(6)}, ${currentCenter.lng.toFixed(6)}, ${currentZoom}`,
          `${currentCenter.lat.toFixed(6)}, ${currentCenter.lng.toFixed(6)}, ${currentZoom}`
        );
        
        if (input === null) return;
        
        const parts = input.split(',').map(p => p.trim());
        
        if (parts.length !== 3) {
          alert('Invalid format. Please enter: latitude, longitude, zoom');
          return;
        }
        
        const lat = parseFloat(parts[0]);
        const lng = parseFloat(parts[1]);
        const zoom = parseInt(parts[2]);
        
        if (isNaN(lat) || isNaN(lng) || isNaN(zoom)) {
          alert('Invalid coordinates or zoom level.');
          return;
        }
        
        if (lat < -90 || lat > 90 || lng < -180 || lng > 180 || zoom < 1 || zoom > 18) {
          alert('Invalid ranges. Lat: -90 to 90, Lng: -180 to 180, Zoom: 1 to 18');
          return;
        }
        
        mapCenter = { lat, lng, zoom };
        try {
          localStorage.setItem(LS_MAP_CENTER, JSON.stringify(mapCenter));
        } catch (e) {}
        
        map.setView([lat, lng], zoom);
        updateMapCenterDisplay();
        alert('Map center saved!');
      });

      document.getElementById('resetMapCenterBtn').addEventListener('click', () => {
        mapCenter = { ...DEFAULT_MAP_CENTER };
        
        try {
          localStorage.removeItem(LS_MAP_CENTER);
        } catch (e) {}
        
        map.setView([mapCenter.lat, mapCenter.lng], mapCenter.zoom);
        updateMapCenterDisplay();
        alert('Map center reset to default!');
      });

      function savePolygonsToLocalStorage() {
        try {
          const simple = polygons.map(p => ({ 
            name: p.name, 
            coords: p.coords, 
            isCategory: p.isCategory || false,
            categoryLocations: p.categoryLocations || []
          }));
          localStorage.setItem(LS_POLYGONS, JSON.stringify(simple));
        } catch (e) {}
      }
      
      function loadPolygonsFromLocalStorage() {
        try {
          const raw = localStorage.getItem(LS_POLYGONS);
          if (!raw) return;
          const items = JSON.parse(raw);
          if (!Array.isArray(items)) return;
          items.forEach(p => {
            const color = p.isCategory ? 'orange' : 'blue';
            const fillColor = p.isCategory ? 'rgba(255,165,0,0.4)' : 'rgba(0,0,255,0.4)';
            const layer = L.polygon(p.coords, { color, fillColor, weight:2 }).addTo(map);
            const polyObj = { 
              name: p.name, 
              coords: p.coords, 
              layer,
              isCategory: p.isCategory || false,
              categoryLocations: p.categoryLocations || []
            };
            polygons.push(polyObj);
            createLabelForPolygon(polyObj);
          });
          updatePolygonList();
        } catch (e) {}
      }

      function saveCsvToLocalStorage() {
        try { 
          localStorage.setItem(LS_CSV, JSON.stringify({
            rows: csvRows,
            columns: csvColumns,
            locationColumn: locationColumnName,
            filterableColumns: filterableColumns
          })); 
        } catch (e) {}
      }
      
      function loadCsvFromLocalStorage() {
        try {
          const raw = localStorage.getItem(LS_CSV);
          if (!raw) return;
          const data = JSON.parse(raw);
          csvRows = data.rows || [];
          csvColumns = data.columns || [];
          locationColumnName = data.locationColumn || '';
          filterableColumns = data.filterableColumns || [];
          
          if (csvRows.length > 0) {
            activeFilters = {};
            filterableColumns.forEach(col => {
              activeFilters[col] = new Set();
            });
            
            buildDynamicFilters();
            updateCsvSummary();
          }
        } catch (e) {}
      }

      function createLabelForPolygon(poly) {
        let latSum = 0, lngSum = 0;
        poly.coords.forEach(c => { latSum += c[0]; lngSum += c[1]; });
        const centroid = [latSum / poly.coords.length, lngSum / poly.coords.length];
        poly.centroid = centroid;
        
        const iconClass = poly.isCategory ? 'category-label' : 'poly-label';
        const icon = L.divIcon({ className: iconClass, html: `${poly.name}`, iconSize: null });
        const marker = L.marker(centroid, { icon }).addTo(map);
        poly.label = marker;

        marker.on('click', () => {
          showPolygonPopup(poly);
        });
        poly.layer.on('click', () => {
          showPolygonPopup(poly);
        });
        
        poly.layer.on('contextmenu', function (e) {
          try { e.originalEvent.preventDefault(); } catch (_) {}
          if (!confirm(`Delete ${poly.isCategory ? 'category' : 'polygon'} "${poly.name}"?`)) return;
          const idx = polygons.findIndex(p => p.layer === poly.layer);
          if (idx >= 0) deletePolygon(idx);
        });
      }

      document.getElementById('toggleLabels').addEventListener('change', e => {
        const show = e.target.checked;
        polygons.forEach(p => {
          if (!p.label) return;
          if (show) {
            if (!map.hasLayer(p.label)) p.label.addTo(map);
          } else {
            if (map.hasLayer(p.label)) map.removeLayer(p.label);
          }
        });
      });

      document.querySelectorAll('input[name="heatmapMode"]').forEach(radio => {
        radio.addEventListener('change', async () => {
          const mode = radio.value;
          
          if (mode === 'distance') {
            document.getElementById('legendBar').style.background = 'linear-gradient(90deg, rgba(255,0,0,0.9), rgba(0,255,0,0.3))';
            document.getElementById('legendText').textContent = 'Red = Slower/Green = Faster Estimated Avg. Velocity';
            
            if (!_station) {
              alert('Please set a station location first for Distance/Time Map');
              document.querySelector('input[name="heatmapMode"][value="incidents"]').checked = true;
              document.getElementById('legendBar').style.background = 'linear-gradient(90deg, rgba(170,170,170,0.15), rgba(255,0,0,0.9))';
              document.getElementById('legendText').textContent = 'Gray = fewer incidents; Blue = greater incidents';
              return;
            }
            
            if (!csvColumns.includes('timeElapsed')) {
              alert('CSV must include a "timeElapsed" column for Distance/Time Map');
              document.querySelector('input[name="heatmapMode"][value="incidents"]').checked = true;
              document.getElementById('legendBar').style.background = 'linear-gradient(90deg, rgba(170,170,170,0.15), rgba(255,0,0,0.9))';
              document.getElementById('legendText').textContent = 'Gray = fewer incidents; Blue = greater incidents';
              return;
            }
            
            if (!distanceDataCalculated) {
              document.getElementById('distanceLoadingIndicator').style.display = 'block';
              await calculateDistanceTimeRatios();
              document.getElementById('distanceLoadingIndicator').style.display = 'none';
              distanceDataCalculated = true;
            }
            
            updateShading();
          } else {
            document.getElementById('legendBar').style.background = 'linear-gradient(90deg, rgba(170,170,170,0.15), rgba(255,0,0,0.9))';
            document.getElementById('legendText').textContent = 'Gray = fewer incidents; Blue = greater incidents';
            
            updateShading();
          }
        });
      });

      function deletePolygon(index) {
        const p = polygons[index];
        if (!p) return;
        try { if (p.layer) map.removeLayer(p.layer); } catch(e){}
        try { if (p.label) map.removeLayer(p.label); } catch(e){}
        
        delete distanceCache[p.name];
        
        polygons.splice(index,1);
        savePolygonsToLocalStorage();
        saveDistanceCacheToLocalStorage();
        updatePolygonList();
        updateShading();
      }

      function updatePolygonList() {
        const regularCount = polygons.filter(p => !p.isCategory).length;
        const categoryCount = polygons.filter(p => p.isCategory).length;
        let text = `${regularCount} Area(s)`;
        if (categoryCount > 0) {
          text += `, ${categoryCount} Category(ies)`;
        }
        document.getElementById('polygonList').innerText = `Current Selection: ${text}`;
      }

      function resetAll() {
        if (!confirm('This will remove all polygons and CSV data. Continue?')) return;
        polygons.forEach(p => {
          try { map.removeLayer(p.layer); } catch(_){}
          try { map.removeLayer(p.label); } catch(_){}
        });
        polygons = [];
        csvRows = [];
        csvColumns = [];
        locationColumnName = '';
        filterableColumns = [];
        activeFilters = {};
        distanceDataCalculated = false;
        distanceCache = {};
        
        savePolygonsToLocalStorage();
        saveCsvToLocalStorage();
        saveDistanceCacheToLocalStorage();
        updatePolygonList();
        updateCsvSummary();
        updateShading();
        clearDetailsPanel();
        clearDynamicFilters();
      }

      function resetCsvDataOnly() {
        if (!confirm('Delete uploaded CSV rows but keep polygons?')) return;
        csvRows = [];
        csvColumns = [];
        locationColumnName = '';
        filterableColumns = [];
        activeFilters = {};
        distanceDataCalculated = false;
        distanceCache = {};
        
        saveCsvToLocalStorage();
        saveDistanceCacheToLocalStorage();
        updateCsvSummary();
        updateShading();
        clearDetailsPanel();
        clearDynamicFilters();
        alert('CSV data cleared.');
      }

      function updateTempPolygon() {
        if (tempPolygon) {
          map.removeLayer(tempPolygon);
        }
        if (polygonPoints.length >= 2) {
          const color = categoryMode ? 'orange' : 'red';
          const fillColor = categoryMode ? 'rgba(255,165,0,0.3)' : 'rgba(255,0,0,0.3)';
          tempPolygon = L.polygon(polygonPoints, { 
            color, 
            fillColor, 
            weight:2, 
            dashArray:'4' 
          }).addTo(map);
        }
      }

      function createDraggableMarker(latlng, index) {
        const marker = L.circleMarker(latlng, {
          radius: 10,
          fillColor: categoryMode ? '#ff8c00' : '#ff0000',
          color: '#ffffff',
          weight: 3,
          opacity: 1,
          fillOpacity: 0.8
        }).addTo(map);

        let isDragging = false;
        let hasDragged = false;

        marker.on('mousedown', (e) => {
          isDragging = true;
          hasDragged = false;
          map.dragging.disable();
          L.DomEvent.stopPropagation(e);
          L.DomEvent.preventDefault(e);
        });

        const handleMove = (e) => {
          if (isDragging) {
            hasDragged = true;
            marker.setLatLng(e.latlng);
            polygonPoints[index] = [e.latlng.lat, e.latlng.lng];
            updateTempPolygon();
            L.DomEvent.stopPropagation(e);
          }
        };

        const handleUp = () => {
          if (isDragging) {
            isDragging = false;
            map.dragging.enable();
            
            // NEW: Set flag if user actually dragged
            if (hasDragged) {
              justFinishedDragging = true;
              // Clear the flag after a short delay
              setTimeout(() => {
                justFinishedDragging = false;
              }, 50);
            }
          }
        };

        map.on('mousemove', handleMove);
        map.on('mouseup', handleUp);
        marker.on('mouseup', handleUp);

        marker.on('contextmenu', (e) => {
          L.DomEvent.stopPropagation(e);
          L.DomEvent.preventDefault(e);
          if (polygonPoints.length > 3) {
            map.removeLayer(marker);
            map.off('mousemove', handleMove);
            map.off('mouseup', handleUp);
            
            polygonPoints.splice(index, 1);
            tempMarkers.splice(index, 1);
            
            tempMarkers.forEach((m, i) => {
              m._pointIndex = i;
            });
            
            updateTempPolygon();
          } else {
            alert('Need at least 3 points for a polygon.');
          }
        });

        marker._pointIndex = index;
        marker._handleMove = handleMove;
        marker._handleUp = handleUp;
        return marker;
      }

      document.getElementById('categoryModeToggle').addEventListener('change', e => {
        categoryMode = e.target.checked;
        const controls = document.getElementById('categoryModeControls');
        const banner = document.getElementById('categoryModeBanner');
        
        if (categoryMode) {
          controls.style.display = 'block';
          banner.style.display = 'block';
        } else {
          controls.style.display = 'none';
          banner.style.display = 'none';
          
          if (drawing) {
            drawing = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('finishBtn').disabled = true;
            document.getElementById('startCategoryBtn').disabled = false;
            document.getElementById('finishCategoryBtn').disabled = true;
            document.getElementById('locationSelectionContainer').style.display = 'none';
            
            if (tempPolygon) map.removeLayer(tempPolygon);
            tempMarkers.forEach(m => {
              map.removeLayer(m);
              if (m._handleMove) map.off('mousemove', m._handleMove);
              if (m._handleUp) map.off('mouseup', m._handleUp);
            });
            tempMarkers = [];
            polygonPoints = [];
            selectedLocations.clear();
          }
        }
      });

      function getUniqueLocations() {
        const locations = new Set();
        csvRows.forEach(row => {
          const loc = row[locationColumnName];
          if (loc && loc.trim() !== '') {
            locations.add(loc.trim());
          }
        });
        return Array.from(locations).sort();
      }

      function buildLocationCheckboxList() {
        const container = document.getElementById('locationCheckboxList');
        container.innerHTML = '';
        
        const locations = getUniqueLocations();
        
        if (locations.length === 0) {
          container.innerHTML = '<div class="small-note">No locations found in CSV</div>';
          return;
        }
        
        locations.forEach(loc => {
          const item = document.createElement('div');
          item.className = 'location-checkbox-item';
          
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.value = loc;
          checkbox.id = `loc-checkbox-${loc.replace(/\s+/g, '-')}`;
          
          checkbox.addEventListener('change', e => {
            if (e.target.checked) {
              selectedLocations.add(loc);
            } else {
              selectedLocations.delete(loc);
            }
          });
          
          const label = document.createElement('label');
          label.setAttribute('for', checkbox.id);
          label.textContent = loc;
          label.style.cursor = 'pointer';
          
          item.appendChild(checkbox);
          item.appendChild(label);
          container.appendChild(item);
        });
      }

      document.getElementById('startCategoryBtn').addEventListener('click', function () {
        if (csvRows.length === 0) {
          alert('Please upload a CSV file first to create categories.');
          return;
        }
        
        drawing = true;
        polygonPoints = [];
        selectedLocations.clear();
        
        tempMarkers.forEach(m => {
          map.removeLayer(m);
          if (m._handleMove) map.off('mousemove', m._handleMove);
          if (m._handleUp) map.off('mouseup', m._handleUp);
        });
        tempMarkers = [];
        
        if (tempPolygon) map.removeLayer(tempPolygon);
        tempPolygon = null;
        
        this.disabled = true;
        document.getElementById('finishCategoryBtn').disabled = false;
        document.getElementById('locationSelectionContainer').style.display = 'block';
        
        buildLocationCheckboxList();
      });

      document.getElementById('finishCategoryBtn').addEventListener('click', function () {
        drawing = false;
        this.disabled = true;
        document.getElementById('startCategoryBtn').disabled = false;
        document.getElementById('locationSelectionContainer').style.display = 'none';
        
        if (polygonPoints.length < 3) {
          alert('Need at least 3 points.');
          return;
        }
        
        if (selectedLocations.size === 0) {
          alert('Please select at least one location for this category.');
          return;
        }
        
        if (tempPolygon) map.removeLayer(tempPolygon);
        tempMarkers.forEach(m => {
          map.removeLayer(m);
          if (m._handleMove) map.off('mousemove', m._handleMove);
          if (m._handleUp) map.off('mouseup', m._handleUp);
        });
        tempMarkers = [];
        
        let categoryName = prompt('Enter a name for this category:');
        if (!categoryName) categoryName = 'Unnamed Category';
        
        const finalPolygon = L.polygon(polygonPoints, { 
          color:'orange', 
          fillColor:'rgba(255,165,0,0.1)', 
          weight:2 
        }).addTo(map);
        
        const polyObj = { 
          name: categoryName.trim(), 
          coords: polygonPoints, 
          layer: finalPolygon,
          isCategory: true,
          categoryLocations: Array.from(selectedLocations)
        };
        
        let latSum = 0, lngSum = 0;
        polyObj.coords.forEach(c => {
          latSum += c[0];
          lngSum += c[1];
        });
        polyObj.centroid = [latSum / polyObj.coords.length, lngSum / polyObj.coords.length];
        
        polygons.push(polyObj);
        createLabelForPolygon(polyObj);
        savePolygonsToLocalStorage();
        updatePolygonList();
        
        selectedLocations.clear();
        distanceDataCalculated = false;
        
        updateShading();
      });

      document.getElementById('startBtn').addEventListener('click', function () {
        drawing = true;
        polygonPoints = [];
        
        tempMarkers.forEach(m => {
          map.removeLayer(m);
          if (m._handleMove) map.off('mousemove', m._handleMove);
          if (m._handleUp) map.off('mouseup', m._handleUp);
        });
        tempMarkers = [];
        
        if (tempPolygon) map.removeLayer(tempPolygon);
        tempPolygon = null;
        
        this.disabled = true;
        document.getElementById('finishBtn').disabled = false;
      });

      document.getElementById('finishBtn').addEventListener('click', function () {
        drawing = false;
        this.disabled = true;
        document.getElementById('startBtn').disabled = false;
        
        if (polygonPoints.length < 3) {
          alert('Need at least 3 points.');
          return;
        }
        
        if (tempPolygon) map.removeLayer(tempPolygon);
        tempMarkers.forEach(m => {
          map.removeLayer(m);
          if (m._handleMove) map.off('mousemove', m._handleMove);
          if (m._handleUp) map.off('mouseup', m._handleUp);
        });
        tempMarkers = [];
        
        let polyName = prompt('Enter a name for this polygon:');
        if (!polyName) polyName = 'Unnamed Polygon';
        
        const finalPolygon = L.polygon(polygonPoints, { 
          color:'blue', 
          fillColor:'rgba(0,0,255,0.4)', 
          weight:2 
        }).addTo(map);
        
        const polyObj = { 
          name: polyName.trim(), 
          coords: polygonPoints, 
          layer: finalPolygon,
          isCategory: false,
          categoryLocations: []
        };
        
        let latSum = 0, lngSum = 0;
        polyObj.coords.forEach(c => {
          latSum += c[0];
          lngSum += c[1];
        });
        polyObj.centroid = [latSum / polyObj.coords.length, lngSum / polyObj.coords.length];
        
        polygons.push(polyObj);
        createLabelForPolygon(polyObj);
        savePolygonsToLocalStorage();
        updatePolygonList();
        
        distanceDataCalculated = false;
        
        updateShading();
      });

      // MODIFIED: Map click handler with drag detection
      map.on('click', function (e) {
        if (!drawing) return;
        
        // NEW: Prevent adding point if user just finished dragging
        if (justFinishedDragging) {
          return;
        }
        
        const newPoint = [e.latlng.lat, e.latlng.lng];
        const index = polygonPoints.length;
        
        polygonPoints.push(newPoint);
        
        const marker = createDraggableMarker(e.latlng, index);
        tempMarkers.push(marker);
        
        updateTempPolygon();
      });

      document.getElementById('setStationBtn').addEventListener('click', () => {
        alert('Click anywhere on the map to place the station marker.');
        map.once('click', function(e) {
          const latlng = e.latlng;

          if (_station && _station.marker) map.removeLayer(_station.marker);

          const marker = L.marker(latlng, { draggable: true }).addTo(map);
          marker.bindPopup('Station').openPopup();

          marker.on('dragend', () => {
            _station.latlng = marker.getLatLng();
            updateStationDisplay();
            saveStationToLocalStorage();
            
            distanceDataCalculated = false;
            distanceCache = {};
            saveDistanceCacheToLocalStorage();
          });

          marker.on('contextmenu', () => {
            map.removeLayer(marker);
            _station = null;
            updateStationDisplay();
            saveStationToLocalStorage();
            
            distanceDataCalculated = false;
            distanceCache = {};
            saveDistanceCacheToLocalStorage();
            updateShading();
          });

          _station = { marker, latlng };
          updateStationDisplay();
          saveStationToLocalStorage();
          
          distanceDataCalculated = false;
          distanceCache = {};
          saveDistanceCacheToLocalStorage();
        });
      });

      function parseCSV(text) {
        const lines = text.split(/\r?\n/).filter(l => l.trim() !== '');
        if (lines.length === 0) return { rows: [], columns: [], locationColumn: '', filterableColumns: [] };
        
        const headerRaw = lines[0].split(',').map(h=>h.trim());
        csvColumns = headerRaw;
        
        locationColumnName = headerRaw[0];
        
        filterableColumns = [];
        const sampleRow = lines.length > 1 ? lines[1].split(',').map(c=>c.trim()) : [];
        
        headerRaw.forEach((colName, idx) => {
          if (idx === 0) return;
          
          const sampleValue = sampleRow[idx];
          if (sampleValue && !isNaN(sampleValue) && sampleValue !== '') {
            return;
          }
          
          filterableColumns.push(colName);
        });

        const rows = [];
        for (let i = 1; i < lines.length; i++) {
          const cols = lines[i].split(',').map(c=>c.trim());
          if (!cols[0]) continue;
          
          const rowObj = {};
          headerRaw.forEach((colName, idx) => {
            rowObj[colName] = cols[idx] || '';
          });
          
          rows.push(rowObj);
        }
        
        return { rows, columns: csvColumns, locationColumn: locationColumnName, filterableColumns };
      }

      document.getElementById('csvFile').addEventListener('change', function (ev) {
        const f = ev.target.files && ev.target.files[0];
        if (!f) return;
        const rdr = new FileReader();
        rdr.onload = function(e) {
          try {
            const parsed = parseCSV(e.target.result);
            csvRows = parsed.rows;
            csvColumns = parsed.columns;
            locationColumnName = parsed.locationColumn;
            filterableColumns = parsed.filterableColumns;
            
            activeFilters = {};
            filterableColumns.forEach(col => {
              activeFilters[col] = new Set();
            });
            
            distanceDataCalculated = false;
            
            saveCsvToLocalStorage();
            buildDynamicFilters();
            updateCsvSummary();
            updateShading();
            alert(`CSV imported: ${csvRows.length} rows with ${filterableColumns.length} filterable column(s).`);
            clearDetailsPanel();
          } catch (err) {
            alert('CSV parse error: ' + err.message);
          }
        };
        rdr.readAsText(f);
        ev.target.value = '';
      });

      function buildDynamicFilters() {
        const container = document.getElementById('dynamicFiltersContainer');
        container.innerHTML = '';
        
        if (filterableColumns.length === 0) {
          container.innerHTML = '<div class="small-note">No filterable columns detected</div>';
          return;
        }
        
        filterableColumns.forEach(colName => {
          const filterBox = document.createElement('div');
          filterBox.className = 'collapsible-box';
          filterBox.style.marginBottom = '8px';
          
          const filterId = `filter-${colName.replace(/\s+/g, '-')}`;
          
          const header = document.createElement('div');
          header.className = 'collapsible-header';
          header.onclick = () => toggleCollapsible(filterId);
          
          const headerTitle = document.createElement('span');
          headerTitle.textContent = colName;
          
          const headerIcon = document.createElement('span');
          headerIcon.className = 'collapse-icon collapsed';
          headerIcon.id = `${filterId}-icon`;
          headerIcon.textContent = '‚ñº';
          
          header.appendChild(headerTitle);
          header.appendChild(headerIcon);
          filterBox.appendChild(header);
          
          const content = document.createElement('div');
          content.className = 'collapsible-content collapsed';
          content.id = `${filterId}-content`;
          
          const filtersGrid = document.createElement('div');
          filtersGrid.className = 'filters';
          
          const uniqueValues = new Set();
          csvRows.forEach(row => {
            const value = row[colName];
            if (value && value.trim() !== '') {
              uniqueValues.add(value);
            }
          });
          
          const DAY_ORDER = ['M', 'T', 'W', 'Th', 'F', 'Sa', 'Su'];
          const isDayColumn = uniqueValues.size > 0 &&
            Array.from(uniqueValues).every(v => DAY_ORDER.includes(v));
          const sortedValues = isDayColumn
            ? DAY_ORDER.filter(d => uniqueValues.has(d))
            : Array.from(uniqueValues).sort();

          sortedValues.forEach(value => {
            const label = document.createElement('label');
            label.className = 'filter-item';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.dataset.column = colName;
            checkbox.dataset.value = value;
            
            checkbox.addEventListener('change', e => {
              if (e.target.checked) {
                activeFilters[colName].add(value);
              } else {
                activeFilters[colName].delete(value);
              }
              
              const mode = document.querySelector('input[name="heatmapMode"]:checked').value;
              if (mode === 'distance' && distanceDataCalculated) {
                updateDistanceTimeMetrics();
              }
              
              updateCsvSummary();
              updateShading();
            });
            
            label.appendChild(checkbox);
            label.appendChild(document.createTextNode(' ' + value));
            filtersGrid.appendChild(label);
          });
          
          content.appendChild(filtersGrid);
          filterBox.appendChild(content);
          container.appendChild(filterBox);
        });
      }

      function clearDynamicFilters() {
        const container = document.getElementById('dynamicFiltersContainer');
        container.innerHTML = '<div class="small-note">Upload a CSV to see available filters</div>';
      }

      document.getElementById('clearFiltersBtn').addEventListener('click', function () {
        Object.keys(activeFilters).forEach(col => {
          activeFilters[col].clear();
        });
        
        document.querySelectorAll('#dynamicFiltersContainer input[type="checkbox"]').forEach(cb => {
          cb.checked = false;
        });
        
        const mode = document.querySelector('input[name="heatmapMode"]:checked').value;
        if (mode === 'distance' && distanceDataCalculated) {
          updateDistanceTimeMetrics();
        }
        
        updateCsvSummary();
        updateShading();
      });

      document.getElementById('resetDataBtn').addEventListener('click', resetCsvDataOnly);

      function getAggregatedCategoryData(poly) {
        if (!poly.isCategory) return null;
        
        const categoryRows = csvRows.filter(row => {
          const loc = row[locationColumnName];
          return poly.categoryLocations.includes(loc);
        });
        
        const filteredRows = categoryRows.filter(row => {
          for (const colName of filterableColumns) {
            const filterSet = activeFilters[colName];
            if (filterSet && filterSet.size > 0) {
              if (!filterSet.has(row[colName])) {
                return false;
              }
            }
          }
          return true;
        });
        
        return {
          totalRows: categoryRows,
          filteredRows: filteredRows
        };
      }

      function computeCountsForPolygons() {
        const counts = {};
        polygons.forEach(p => {
          if (p.isCategory) {
            const data = getAggregatedCategoryData(p);
            counts[p.name] = data ? data.filteredRows.length : 0;
          } else {
            counts[p.name] = 0;
          }
        });
        
        if (!csvRows || csvRows.length === 0) return counts;

        csvRows.forEach(r => {
          let passesFilters = true;
          
          for (const colName of filterableColumns) {
            const filterSet = activeFilters[colName];
            if (filterSet && filterSet.size > 0) {
              if (!filterSet.has(r[colName])) {
                passesFilters = false;
                break;
              }
            }
          }

          if (passesFilters) {
            const location = r[locationColumnName];
            const poly = polygons.find(p => p.name === location && !p.isCategory);
            if (poly && location in counts) counts[location] += 1;
          }
        });
        
        return counts;
      }

      async function getBikingDistance(fromLat, fromLng, toLat, toLng) {
        const url = `https://router.project-osrm.org/route/v1/bike/${fromLng},${fromLat};${toLng},${toLat}?overview=false`;
        
        try {
          const response = await fetch(url);
          const data = await response.json();
          
          if (data.routes && data.routes.length > 0) {
            return data.routes[0].distance;
          }
          return null;
        } catch (error) {
          console.error('OSRM API error:', error);
          return null;
        }
      }

      async function calculateDistanceTimeRatios() {
        if (!_station || polygons.length === 0 || csvRows.length === 0) {
          return;
        }

        const stationLat = _station.latlng.lat;
        const stationLng = _station.latlng.lng;

        for (const poly of polygons) {
          if (!distanceCache[poly.name] || distanceCache[poly.name].distance === undefined) {
            const [polyLat, polyLng] = poly.centroid;
            const distanceMeters = await getBikingDistance(stationLat, stationLng, polyLat, polyLng);
            
            const distanceMiles = distanceMeters ? distanceMeters * 0.000621371 : null;

            distanceCache[poly.name] = {
              distance: distanceMiles,
              avgTime: 0,
              ratio: 0
            };

            await new Promise(resolve => setTimeout(resolve, 100));
          }
        }
        
        updateDistanceTimeMetrics();
        saveDistanceCacheToLocalStorage();
      }
      
      function updateDistanceTimeMetrics() {
        for (const poly of polygons) {
          let incidents;
          
          if (poly.isCategory) {
            const data = getAggregatedCategoryData(poly);
            incidents = data ? data.filteredRows.filter(r => r.timeElapsed) : [];
          } else {
            incidents = csvRows.filter(r => {
              if (r[locationColumnName] !== poly.name) return false;
              if (!r.timeElapsed) return false;
              
              for (const colName of filterableColumns) {
                const filterSet = activeFilters[colName];
                if (filterSet && filterSet.size > 0) {
                  if (!filterSet.has(r[colName])) {
                    return false;
                  }
                }
              }
              
              return true;
            });
          }
          
          if (incidents.length === 0 || !distanceCache[poly.name]) {
            if (distanceCache[poly.name]) {
              distanceCache[poly.name].avgTime = 0;
              distanceCache[poly.name].ratio = 0;
            }
            continue;
          }

          const totalTime = incidents.reduce((sum, incident) => {
            return sum + (parseFloat(incident.timeElapsed) || 0);
          }, 0);
          const avgTime = totalTime / incidents.length;

          const distanceMiles = distanceCache[poly.name].distance;
          const ratio = avgTime > 0 && distanceMiles ? distanceMiles / avgTime : 0;

          distanceCache[poly.name].avgTime = avgTime;
          distanceCache[poly.name].ratio = ratio;
        }
      }

      function interpolateColor(c1, c2, t) {
        const r1 = parseInt(c1.slice(1,3),16), g1 = parseInt(c1.slice(3,5),16), b1 = parseInt(c1.slice(5,7),16);
        const r2 = parseInt(c2.slice(1,3),16), g2 = parseInt(c2.slice(3,5),16), b2 = parseInt(c2.slice(5,7),16);
        const r = Math.round(r1 + (r2 - r1) * t);
        const g = Math.round(g1 + (g2 - g1) * t);
        const b = Math.round(b1 + (b2 - b1) * t);
        return `rgb(${r},${g},${b})`;
      }

      function updateShading() {
        const mode = document.querySelector('input[name="heatmapMode"]:checked').value;
        
        if (mode === 'distance') {
          if (!distanceDataCalculated || Object.keys(distanceCache).length === 0) {
            polygons.forEach(p => {
              p.layer.setStyle({ color: '#aaaaaa', fillColor: '#aaaaaa', fillOpacity: 0.4, weight: 2 });
            });
            
            if (_station && csvRows.length > 0 && polygons.length > 0) {
              document.getElementById('distanceLoadingIndicator').style.display = 'block';
              calculateDistanceTimeRatios().then(() => {
                document.getElementById('distanceLoadingIndicator').style.display = 'none';
                distanceDataCalculated = true;
                updateShading();
              });
            }
            return;
          }

          const ratios = Object.values(distanceCache).map(d => d.ratio).filter(r => r > 0);
          if (ratios.length === 0) {
            polygons.forEach(p => {
              p.layer.setStyle({ color: '#aaaaaa', fillColor: '#aaaaaa', fillOpacity: 0.4, weight: 2 });
            });
            return;
          }

          const maxRatio = Math.max(...ratios);
          const minRatio = Math.min(...ratios);

          polygons.forEach(p => {
            const data = distanceCache[p.name];
            if (!data || data.ratio === 0) {
              p.layer.setStyle({ color: '#aaaaaa', fillColor: '#aaaaaa', fillOpacity: 0.4, weight: 2 });
              return;
            }

            let color, opacity;
            
            const range = maxRatio - minRatio;
            if (range > 0) {
              const normalizedValue = (data.ratio - minRatio) / range;
              color = interpolateColor('#ff0000', '#00ff00', normalizedValue);
              opacity = 0.5 + (normalizedValue * 0.4);
            } else {
              color = '#00ff00';
              opacity = 0.7;
            }

            p.layer.setStyle({
              color: color,
              fillColor: color,
              fillOpacity: opacity,
              weight: 2
            });
          });

          updateCsvSummary();
          return;
        }

        const counts = computeCountsForPolygons();
        let max = 0;
        Object.values(counts).forEach(v => { if (v>max) max=v; });
        
        polygons.forEach(p => {
          const c = counts[p.name] || 0;
          const ratio = max > 0 ? c / max : 0;
          const boosted = Math.pow(ratio, 0.55);
          const opacity = 0.45 + boosted * 0.55;

          const baseColor = p.isCategory ? "#ff8c00" : "#0000ff";
          const fillColor = interpolateColor("#aaaaaa", baseColor, boosted);

          p.layer.setStyle({
            color: fillColor,
            fillColor: fillColor,
            fillOpacity: opacity,
            weight: 2
          });
        });
        
        updateCsvSummary();
      }

      function updateCsvSummary() {
        const el = document.getElementById('csvSummary');
        const mode = document.querySelector('input[name="heatmapMode"]:checked').value;
        
        if (!csvRows || csvRows.length === 0) {
          el.innerText = 'No CSV loaded';
          return;
        }

        if (mode === 'distance' && distanceDataCalculated) {
          const ratioEntries = Object.entries(distanceCache)
            .filter(([name, data]) => data.ratio > 0)
            .map(([name, data]) => ({ name, ratio: data.ratio, avgTime: data.avgTime }))
            .sort((a, b) => b.ratio - a.ratio);
          
          if (ratioEntries.length === 0) {
            el.innerText = 'No distance/time data available';
            return;
          }
          
          if (ratioEntries.length <= 6) {
            const lines = ratioEntries.map(e => `${e.name}: ${e.ratio.toFixed(3)} mi/min (${e.avgTime.toFixed(1)} min)`);
            el.innerText = `Efficiency Rankings:\n${lines.join('\n')}`;
          } else {
            const top3 = ratioEntries.slice(0, 3);
            const bottom3 = ratioEntries.slice(-3).reverse();
            
            const topLines = top3.map(e => `‚úì ${e.name}: ${e.ratio.toFixed(3)} mi/min (${e.avgTime.toFixed(1)} min)`);
            const bottomLines = bottom3.map(e => `‚úó ${e.name}: ${e.ratio.toFixed(3)} mi/min (${e.avgTime.toFixed(1)} min)`);
            
            el.innerText = `Top 3 Fastest:\n${topLines.join('\n')}\n\nBottom 3 Slowest:\n${bottomLines.join('\n')}`;
          }
          return;
        }

        let totalActive = 0, matched = 0, unmatched = 0;
        const namesSet = new Set(polygons.map(p=>p.name));

        csvRows.forEach(r => {
          let passesFilters = true;
          
          for (const colName of filterableColumns) {
            const filterSet = activeFilters[colName];
            if (filterSet && filterSet.size > 0) {
              if (!filterSet.has(r[colName])) {
                passesFilters = false;
                break;
              }
            }
          }

          if (passesFilters) {
            totalActive++;
            if (namesSet.has(r[locationColumnName])) matched++;
            else unmatched++;
          }
        });

        const counts = computeCountsForPolygons();
        const entries = Object.entries(counts).sort((a,b)=>b[1]-a[1]);
        const lines = entries.slice(0,3).map(e=>`${e[0]}: ${e[1]}`);
        const more = entries.length>3 ? `\n+ ${entries.length-3} more...` : '';

        el.innerText = `Top Incident Locations:\n${lines.join('\n')}${more}`;
      }

      function showPolygonPopup(poly) {
        let allMatches, filteredMatches;
        
        if (poly.isCategory) {
          const data = getAggregatedCategoryData(poly);
          allMatches = data ? data.totalRows : [];
          filteredMatches = data ? data.filteredRows : [];
        } else {
          allMatches = csvRows.filter(r => r[locationColumnName] === poly.name);
          
          filteredMatches = allMatches.filter(row => {
            for (const colName of filterableColumns) {
              const filterSet = activeFilters[colName];
              if (filterSet && filterSet.size > 0) {
                if (!filterSet.has(row[colName])) {
                  return false;
                }
              }
            }
            return true;
          });
        }
        
        let popupHTML = `<div class="poly-popup">`;
        popupHTML += `<div class="popup-title">${poly.name}${poly.isCategory ? ' (Category)' : ''}</div>`;
        
        if (poly.isCategory) {
          popupHTML += `<div style="font-size:12px; color:#92400e; margin-bottom:8px; padding:6px; background:#fef3c7; border-radius:4px;">`;
          popupHTML += `üìÅ Includes: ${poly.categoryLocations.join(', ')}`;
          popupHTML += `</div>`;
        }
        
        popupHTML += `<div style="font-size:14px; color:#6b7280; margin-bottom:10px;">Filtered Incidents: ${filteredMatches.length}`;
        if (filteredMatches.length !== allMatches.length) {
          popupHTML += ` <span style="color:#9ca3af;">(${allMatches.length} total)</span>`;
        }
        popupHTML += `</div>`;
        
        const mode = document.querySelector('input[name="heatmapMode"]:checked').value;
        if (mode === 'distance' && distanceCache[poly.name]) {
          const data = distanceCache[poly.name];
          
          const allIncidents = allMatches.filter(r => r.timeElapsed);
          let totalAvgTime = 0;
          let totalRatio = 0;
          
          if (allIncidents.length > 0) {
            const totalTime = allIncidents.reduce((sum, incident) => {
              return sum + (parseFloat(incident.timeElapsed) || 0);
            }, 0);
            totalAvgTime = totalTime / allIncidents.length;
            
            const distanceMiles = distanceCache[poly.name].distance;
            if (totalAvgTime > 0 && distanceMiles) {
              totalRatio = distanceMiles / totalAvgTime;
            }
          }
          
          popupHTML += `<div style="font-size:14px; background:#f0f9ff; padding:6px; border-radius:4px; margin-bottom:10px;">`;
          
          popupHTML += `<div style="font-weight:600; margin-bottom:4px; color:#0369a1;">Filtered Metrics:</div>`;
          popupHTML += `<div style="margin-left:8px;"><strong>Avg Time:</strong> ${data.avgTime ? data.avgTime.toFixed(1) + ' min' : 'N/A'}</div>`;
          popupHTML += `<div style="margin-left:8px; margin-bottom:6px;"><strong>Efficiency:</strong> ${data.ratio ? data.ratio.toFixed(3) + ' mi/min' : 'N/A'}</div>`;
          
          if (filteredMatches.length !== allMatches.length && totalAvgTime > 0) {
            popupHTML += `<div style="font-weight:600; margin-bottom:4px; color:#6b7280; border-top:1px solid #e0f2fe; padding-top:4px;">Total (Unfiltered):</div>`;
            popupHTML += `<div style="margin-left:8px;"><strong>Avg Time:</strong> ${totalAvgTime.toFixed(1)} min</div>`;
            popupHTML += `<div style="margin-left:8px;"><strong>Efficiency:</strong> ${totalRatio.toFixed(3)} mi/min</div>`;
          }
          
          popupHTML += `</div>`;
        }
        
        if (filteredMatches.length === 0) {
          popupHTML += `<div style="color:#9ca3af; font-size:12px;">No incidents match current filters</div>`;
          popupHTML += `</div>`;
          poly.layer.bindPopup(popupHTML, { maxWidth: 300, maxHeight: 300 }).openPopup();
          return;
        }
        
        filterableColumns.forEach(colName => {
          const valueCounts = {};
          filteredMatches.forEach(row => {
            const val = row[colName] || '(empty)';
            valueCounts[val] = (valueCounts[val] || 0) + 1;
          });
          
          const bodyId = `popup-body-${poly.name}-${colName}`.replace(/\s+/g, '-');
          
          popupHTML += `<div class="popup-section">`;
          popupHTML += `<div class="popup-section-header" onclick="togglePopupSection('${bodyId}')">`;
          popupHTML += `<span>${colName}</span>`;
          popupHTML += `<span style="color:#6b7280;">‚ñº</span>`;
          popupHTML += `</div>`;
          popupHTML += `<div class="popup-section-body" id="${bodyId}" style="display:none;">`;
          
          Object.entries(valueCounts).sort((a,b) => b[1] - a[1]).forEach(([val, count]) => {
            popupHTML += `<div style="padding:3px 0;">${val}: <strong>${count}</strong></div>`;
          });
          
          popupHTML += `</div></div>`;
        });
        
        const filteredListBodyId = `popup-filtered-list-${poly.name}`.replace(/\s+/g, '-');
        popupHTML += `<div class="popup-section">`;
        popupHTML += `<div class="popup-section-header" onclick="togglePopupSection('${filteredListBodyId}')">`;
        popupHTML += `<span>Filtered Incidents</span>`;
        popupHTML += `<span style="color:#6b7280;">‚ñº</span>`;
        popupHTML += `</div>`;
        popupHTML += `<div class="popup-section-body" id="${filteredListBodyId}" style="display:none;">`;
        popupHTML += `<div class="popup-table-wrapper">`;
        popupHTML += `<table style="width:100%; font-size:11px; border-collapse:collapse;">`;
        popupHTML += `<thead><tr>`;
        
        csvColumns.forEach(col => {
          popupHTML += `<th style="border-bottom:1px solid #e5e7eb; padding:4px; text-align:left; white-space:nowrap;">${col}</th>`;
        });
        
        popupHTML += `</tr></thead><tbody>`;
        
        filteredMatches.forEach(row => {
          popupHTML += `<tr>`;
          csvColumns.forEach(col => {
            popupHTML += `<td style="border-bottom:1px solid #f3f4f6; padding:4px; white-space:nowrap;">${row[col] || ''}</td>`;
          });
          popupHTML += `</tr>`;
        });
        
        popupHTML += `</tbody></table></div></div></div>`;
        
        if (filteredMatches.length !== allMatches.length) {
          const allListBodyId = `popup-all-list-${poly.name}`.replace(/\s+/g, '-');
          popupHTML += `<div class="popup-section">`;
          popupHTML += `<div class="popup-section-header" onclick="togglePopupSection('${allListBodyId}')">`;
          popupHTML += `<span>All Incidents (Unfiltered)</span>`;
          popupHTML += `<span style="color:#6b7280;">‚ñº</span>`;
          popupHTML += `</div>`;
          popupHTML += `<div class="popup-section-body" id="${allListBodyId}" style="display:none;">`;
          popupHTML += `<div class="popup-table-wrapper">`;
          popupHTML += `<table style="width:100%; font-size:11px; border-collapse:collapse;">`;
          popupHTML += `<thead><tr>`;
          
          csvColumns.forEach(col => {
            popupHTML += `<th style="border-bottom:1px solid #e5e7eb; padding:4px; text-align:left; white-space:nowrap;">${col}</th>`;
          });
          
          popupHTML += `</tr></thead><tbody>`;
          
          allMatches.forEach(row => {
            popupHTML += `<tr>`;
            csvColumns.forEach(col => {
              popupHTML += `<td style="border-bottom:1px solid #f3f4f6; padding:4px; white-space:nowrap;">${row[col] || ''}</td>`;
            });
            popupHTML += `</tr>`;
          });
          
          popupHTML += `</tbody></table></div></div></div>`;
        }
        
        popupHTML += `</div>`;
        
        poly.layer.bindPopup(popupHTML, { maxWidth: 300, maxHeight: 300 }).openPopup();
      }
      
      window.togglePopupSection = function(bodyId) {
        const body = document.getElementById(bodyId);
        if (body) {
          body.style.display = body.style.display === 'none' ? 'block' : 'none';
        }
      };

      function clearDetailsPanel() {
        document.getElementById('detailsTbody').innerHTML = '';
        document.getElementById('detailsTableHead').querySelector('tr').innerHTML = '';
        document.getElementById('detailsScroll').style.display = 'none';
        document.getElementById('summaryContainer').innerHTML = '';
        document.getElementById('summaryContainer').style.display = 'none';
      }

      function exportPolygonsToFile() {
        try {
          const payload = polygons.map(p => ({ 
            name: p.name, 
            coords: p.coords,
            isCategory: p.isCategory || false,
            categoryLocations: p.categoryLocations || []
          }));
          const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'mapping_area_designations.json';
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
        } catch (err) {
          alert('Export failed: ' + (err && err.message ? err.message : err));
        }
      }

      function importPolygonsFromFile(file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            const data = JSON.parse(e.target.result);
            if (!Array.isArray(data)) throw new Error('Invalid format');

            polygons.forEach(p => {
              try { if (p.layer) map.removeLayer(p.layer); } catch(_) {}
              try { if (p.label) map.removeLayer(p.label); } catch(_) {}
            });
            polygons = [];

            data.forEach(item => {
              const color = item.isCategory ? 'orange' : 'blue';
              const fillColor = item.isCategory ? 'rgba(255,165,0,0.4)' : 'rgba(0,0,255,0.4)';
              const layer = L.polygon(item.coords, { color, fillColor, weight:2 }).addTo(map);
              const polyObj = { 
                name: item.name, 
                coords: item.coords, 
                layer,
                isCategory: item.isCategory || false,
                categoryLocations: item.categoryLocations || []
              };
              polygons.push(polyObj);
              createLabelForPolygon(polyObj);
            });

            savePolygonsToLocalStorage();
            updatePolygonList();
            
            distanceDataCalculated = false;
            distanceCache = {};
            saveDistanceCacheToLocalStorage();
            
            updateShading();
            clearDetailsPanel();
          } catch (err) {
            alert('Import failed: ' + (err && err.message ? err.message : err));
          }
        };
        reader.readAsText(file);
      }

      document.getElementById('exportPolygonsBtn').addEventListener('click', exportPolygonsToFile);
      document.getElementById('importPolygonsFile').addEventListener('change', function(ev) {
        const f = ev.target.files && ev.target.files[0];
        if (!f) return;
        importPolygonsFromFile(f);
        ev.target.value = '';
      });

      document.getElementById('resetBtn').addEventListener('click', resetAll);

      loadCsvFromLocalStorage();
      loadPolygonsFromLocalStorage();
      loadStationFromLocalStorage();
      loadDistanceCacheFromLocalStorage();
      updateShading();
      clearDetailsPanel();
      updateMapCenterDisplay();

      window._polyApp = { polygons, csvRows, updateShading, resetAll, resetCsvDataOnly, distanceCache };
    </script>
  </body>
</html>
